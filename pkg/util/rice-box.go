// Code generated by rice embed-go; DO NOT EDIT.
package util

import (
	"time"

	"github.com/GeertJohan/go.rice/embedded"
)

func init() {

	// define files
	file3 := &embedded.EmbeddedFile{
		Filename:    "agent/check_prereqs.sh",
		FileModTime: time.Unix(1681101988, 0),

		Content: string("#!/bin/sh\nset -x\n\n# Check can sudo without password\nif ! $(sudo ls /tmp/ > /dev/null); then\n\tMSG=\"Unable to successfully use sudo with user $USER on this host.\\nUser $USER must be in sudoers group and using sudo without password must be enabled.\\nPlease see iofog.org documentation for more details.\"\n\techo $MSG\n\texit 1\nfi\n"),
	}
	file4 := &embedded.EmbeddedFile{
		Filename:    "agent/init.sh",
		FileModTime: time.Unix(1744129632, 0),

		Content: string("#!/bin/sh\n# Script to detect Linux distribution and version\n# Used as a precursor for system-specific installations\n\n# Exit on error and print commands for debugging\nset -e\nset -x\n\n# Define user variable\nuser=\"$(id -un 2>/dev/null || true)\"\n\n# Check if a command exists\ncommand_exists() {\n    command -v \"$@\" > /dev/null 2>&1\n}\n\n# Detect the Linux distribution\nget_distribution() {\n    lsb_dist=\"\"\n    dist_version=\"\"\n    \n    # Every system that we officially support has /etc/os-release\n    if [ -r /etc/os-release ]; then\n        \n        lsb_dist=\"$(. /etc/os-release && echo \"$ID\")\"\n        \n        dist_version=\"$(. /etc/os-release && echo \"$VERSION_ID\")\"\n        lsb_dist=\"$(echo \"$lsb_dist\" | tr '[:upper:]' '[:lower:]')\"\n    else\n        echo \"Error: Unsupported Linux distribution! /etc/os-release not found.\"\n        exit 1\n    fi\n    \n    echo \"# Detected distribution: $lsb_dist (version: $dist_version)\"\n}\n\n# Check if this is a forked Linux distro\ncheck_forked() {\n    # Skip if lsb_release doesn't exist\n    if ! command_exists lsb_release; then\n        return\n    fi\n    \n    # Check if the `-u` option is supported\n    set +e\n    lsb_release -a > /dev/null 2>&1\n    lsb_release_exit_code=$?\n    set -e\n\n    # Check if the command has exited successfully, it means we're in a forked distro\n    if [ \"$lsb_release_exit_code\" = \"0\" ]; then\n        # Get the upstream release info\n        current_lsb_dist=$(lsb_release -a 2>&1 | tr '[:upper:]' '[:lower:]' | grep -E 'id' | cut -d ':' -f 2 | tr -d '[:space:]')\n        current_dist_version=$(lsb_release -a 2>&1 | tr '[:upper:]' '[:lower:]' | grep -E 'codename' | cut -d ':' -f 2 | tr -d '[:space:]')\n\n        # Print info about current distro\n        echo \"You're using '$current_lsb_dist' version '$current_dist_version'.\"\n        \n        # Check if current is different from detected (indicating a fork)\n        if [ \"$current_lsb_dist\" != \"$lsb_dist\" ] || [ \"$current_dist_version\" != \"$dist_version\" ]; then\n            echo \"Upstream release is '$lsb_dist' version '$dist_version'.\"\n        fi\n    else\n        # Additional checks for specific distros that might not be properly detected\n        if [ -r /etc/debian_version ] && [ \"$lsb_dist\" != \"ubuntu\" ] && [ \"$lsb_dist\" != \"raspbian\" ]; then\n            if [ \"$lsb_dist\" = \"osmc\" ]; then\n                # OSMC runs Raspbian\n                lsb_dist=raspbian\n            else\n                # We're Debian and don't even know it!\n                lsb_dist=debian\n            fi\n            # Get Debian version and map it to codename\n            dist_version=\"$(sed 's/\\/.*//' /etc/debian_version | sed 's/\\..*//')\"\n            case \"$dist_version\" in\n                14)\n                    dist_version=\"forky\"\n                ;;\n                13)\n                    dist_version=\"trixie\"\n                ;;\n                12)\n                    dist_version=\"bookworm\"\n                ;;\n                11)\n                    dist_version=\"bullseye\"\n                ;;\n                10)\n                    dist_version=\"buster\"\n                ;;\n                9)\n                    dist_version=\"stretch\"\n                ;;\n                8|'Kali Linux 2')\n                    dist_version=\"jessie\"\n                ;;\n                7)\n                    dist_version=\"wheezy\"\n                ;;\n            esac\n        elif [ -r /etc/redhat-release ] && [ -z \"$lsb_dist\" ]; then\n            lsb_dist=redhat\n            # Extract version from redhat-release file\n            dist_version=\"$(sed 's/.*release \\([0-9.]*\\).*/\\1/' /etc/redhat-release)\"\n        fi\n    fi\n}\n\n# Set up sudo command if necessary\nsetup_sudo() {\n    sh_c='sh -c'\n    if [ \"$user\" != 'root' ]; then\n        if command_exists sudo; then\n            sh_c='sudo -E sh -c'\n        elif command_exists su; then\n            sh_c='su -c'\n        else\n            echo \"Error: this installer needs the ability to run commands as root.\"\n            echo \"We are unable to find either 'sudo' or 'su' available to make this happen.\"\n            exit 1\n        fi\n    fi\n    echo \"# Using command executor: $sh_c\"\n}\n\n# Refine distribution version detection based on the distro\nrefine_distribution_version() {\n    case \"$lsb_dist\" in\n        ubuntu)\n            if command_exists lsb_release; then\n                dist_version=\"$(lsb_release --codename | cut -f2)\"\n            fi\n            if [ -z \"$dist_version\" ] && [ -r /etc/lsb-release ]; then\n                \n                dist_version=\"$(. /etc/lsb-release && echo \"$DISTRIB_CODENAME\")\"\n            fi\n        ;;\n\n        debian|raspbian)\n            # If we only have a number, map it to a codename for better recognition\n            if echo \"$dist_version\" | grep -qE '^[0-9]+$'; then\n                case \"$dist_version\" in\n                    14)\n                        dist_version=\"forky\"\n                    ;;\n                    13)\n                        dist_version=\"trixie\"\n                    ;;\n                    12)\n                        dist_version=\"bookworm\"\n                    ;;\n                    11)\n                        dist_version=\"bullseye\"\n                    ;;\n                    10)\n                        # Handle special case for Buster\n                        dist_version=\"buster\"\n                        if [ \"$user\" = 'root' ]; then\n                            apt-get update --allow-releaseinfo-change || true\n                        elif command_exists sudo; then\n                            sudo apt-get update --allow-releaseinfo-change || true\n                        fi\n                    ;;\n                    9)\n                        dist_version=\"stretch\"\n                    ;;\n                    8)\n                        dist_version=\"jessie\"\n                    ;;\n                    7)\n                        dist_version=\"wheezy\"\n                    ;;\n                esac\n            fi\n        ;;\n\n        centos|rhel|fedora|ol)\n            # Make sure we have a version number\n            if [ -z \"$dist_version\" ] && [ -r /etc/os-release ]; then\n                \n                dist_version=\"$(. /etc/os-release && echo \"$VERSION_ID\")\"\n            fi\n            if [ -z \"$dist_version\" ] && [ -r /etc/redhat-release ]; then\n                dist_version=\"$(sed 's/.*release \\([0-9.]*\\).*/\\1/' /etc/redhat-release)\"\n            fi\n        ;;\n\n        sles|opensuse)\n            if [ -z \"$dist_version\" ] && [ -r /etc/os-release ]; then\n                dist_version=\"$(. /etc/os-release && echo \"$VERSION_ID\")\"\n            fi\n            # Fallback for older versions\n            if [ -z \"$dist_version\" ] && [ -r /etc/SuSE-release ]; then\n                dist_version=\"$(grep VERSION /etc/SuSE-release | sed 's/^VERSION = //')\"\n            fi\n            # Ensure version is in the correct format (e.g., 15.4 for SLES 15 SP4)\n            if [ -n \"$dist_version\" ]; then\n                # Remove any non-numeric characters except dots\n                dist_version=\"$(echo \"$dist_version\" | sed 's/[^0-9.]//g')\"\n            fi\n            # Normalize distribution name\n            if [ \"$lsb_dist\" = \"sles\" ]; then\n                lsb_dist=\"sles\"\n            elif [ \"$lsb_dist\" = \"opensuse\" ]; then\n                lsb_dist=\"opensuse\"\n            fi\n        ;;\n\n        *)\n            if command_exists lsb_release; then\n                dist_version=\"$(lsb_release --release | cut -f2)\"\n            fi\n            if [ -z \"$dist_version\" ] && [ -r /etc/os-release ]; then\n                \n                dist_version=\"$(. /etc/os-release && echo \"$VERSION_ID\")\"\n            fi\n        ;;\n    esac\n}\n\n# Init function\ninit() {\n    # Detect basic distribution info\n    get_distribution\n    \n    # Set up sudo for privileged commands\n    setup_sudo\n    \n    # Refine version information\n    refine_distribution_version\n    \n    # Check if this is a forked distro\n    check_forked\n    \n    # Print final distribution information\n    echo \"----------------------------------------\"\n    echo \"Linux Distribution: $lsb_dist\"\n    echo \"Version: $dist_version\"\n    echo \"----------------------------------------\"\n    \n}\n"),
	}
	file5 := &embedded.EmbeddedFile{
		Filename:    "agent/install_deps.sh",
		FileModTime: time.Unix(1733131948, 0),

		Content: string("#!/bin/sh\nset -x\nset -e\n\n/etc/iofog/agent/install_java.sh\n/etc/iofog/agent/install_docker.sh\n"),
	}
	file6 := &embedded.EmbeddedFile{
		Filename:    "agent/install_docker.sh",
		FileModTime: time.Unix(1744125008, 0),

		Content: string("#!/bin/sh\n# Script to install Docker/Podman based on Linux distribution\n# Sources init.sh for distribution detection\n\nset -x\nset -e\n\nstart_docker() {\n    set +e\n    # check if docker is running\n    if ! $sh_c \"docker ps\" >/dev/null 2>&1; then\n        # Try init.d\n        $sh_c \"/etc/init.d/docker start\" >/dev/null 2>&1\n        local err_code=$?\n        # Try systemd\n        if [ $err_code -ne 0 ]; then\n            $sh_c \"systemctl start docker\" >/dev/null 2>&1\n            err_code=$?\n        fi\n        # Try service\n        if [ $err_code -ne 0 ]; then\n            $sh_c \"service docker start\" >/dev/null 2>&1\n            err_code=$?\n        fi\n        # Try snapd\n        if [ $err_code -ne 0 ]; then\n            $sh_c \"snap start docker\" >/dev/null 2>&1\n            err_code=$?\n        fi\n        if [ $err_code -ne 0 ]; then\n            echo \"Could not start Docker daemon\"\n            exit 1\n        fi\n    fi\n    set -e\n}\n\n\ndo_modify_daemon() {\n    # Skip for Podman installations\n    if [ \"$USE_PODMAN\" = \"true\" ]; then\n        echo \"# Configuring Podman for CDI directory support...\"\n\n        # Create CDI directories\n        $sh_c \"mkdir -p /etc/cdi /var/run/cdi\"\n\n        # Ensure /etc/containers exists\n        $sh_c \"mkdir -p /etc/containers\"\n\n        # Create containers.conf if it doesn't exist\n        if [ ! -f \"/etc/containers/containers.conf\" ]; then\n            $sh_c 'cat > /etc/containers/containers.conf <<EOF\n[engine]\nruntime = \"crun\"\ncdi_spec_dirs = [\"/etc/cdi\", \"/var/run/cdi\"]\nEOF'\n        else\n            # Check if [engine] block exists\n            if grep -q \"^\\[engine\\]\" /etc/containers/containers.conf; then\n                # Ensure runtime is set under [engine]\n                if grep -q \"^runtime\" /etc/containers/containers.conf; then\n                    $sh_c \"sed -i 's|^runtime *=.*|runtime = \\\"crun\\\"|' /etc/containers/containers.conf\"\n                else\n                    $sh_c \"sed -i '/^\\[engine\\]/a runtime = \\\"crun\\\"' /etc/containers/containers.conf\"\n                fi\n\n                # Ensure cdi_spec_dirs is set under [engine]\n                if grep -q \"^cdi_spec_dirs\" /etc/containers/containers.conf; then\n                    $sh_c \"sed -i 's|^cdi_spec_dirs *=.*|cdi_spec_dirs = [\\\"/etc/cdi\\\", \\\"/var/run/cdi\\\"]|' /etc/containers/containers.conf\"\n                else\n                    $sh_c \"sed -i '/^\\[engine\\]/a cdi_spec_dirs = [\\\"/etc/cdi\\\", \\\"/var/run/cdi\\\"]' /etc/containers/containers.conf\"\n                fi\n            else\n                # Append full engine block if missing\n                $sh_c 'echo -e \"\\n[engine]\\nruntime = \\\"crun\\\"\\ncdi_spec_dirs = [\\\"/etc/cdi\\\", \\\"/var/run/cdi\\\"]\" >> /etc/containers/containers.conf'\n            fi\n        fi\n\n        # Enable and start Podman services\n        $sh_c \"systemctl enable podman\"\n        $sh_c \"systemctl start podman\"\n        $sh_c \"systemctl enable podman.socket\"\n        $sh_c \"systemctl start podman.socket\"\n        return\n    fi\n    \n    # Original Docker daemon configuration\n    if [ ! -f /etc/docker/daemon.json ]; then\n        echo \"Creating /etc/docker/daemon.json...\"\n        $sh_c \"mkdir -p /etc/docker\"\n        $sh_c 'cat > /etc/docker/daemon.json << EOF\n{\n\t\"storage-driver\": \"overlayfs\",\n    \"features\": {\n        \"containerd-snapshotter\": true,\n        \"cdi\": true\n    },\n    \"cdi-spec-dirs\": [\"/etc/cdi/\", \"/var/run/cdi\"]\n}\nEOF'\n    else\n        echo \"/etc/docker/daemon.json already exists\"\n    fi\n    echo \"Restarting Docker daemon...\"\n    $sh_c \"systemctl daemon-reload\"\n    $sh_c \"systemctl restart docker\"\n}\n\ndo_set_datasance_repo() {\n    echo \"# Setting up Datasance repository for $lsb_dist...\"\n    \n    case \"$lsb_dist\" in\n        fedora|centos|rhel|ol|sles|opensuse*)\n            # RPM-based distros\n            $sh_c \"cd /etc/yum.repos.d && curl -s https://downloads.datasance.com/datasance.repo -LO\"\n            if [ \"$lsb_dist\" = \"fedora\" ] || [ \"$lsb_dist\" = \"centos\" ] || [ \"$lsb_dist\" = \"rhel\" ] || [ \"$lsb_dist\" = \"ol\" ]; then\n                $sh_c \"yum update -y\"\n            else\n                $sh_c \"zypper refresh\"\n            fi\n        ;;\n        debian|ubuntu|raspbian|*)\n            # DEB-based distros\n            $sh_c \"apt update -qy\"\n            $sh_c \"apt install -qy debian-archive-keyring apt-transport-https\"\n            $sh_c \"wget -qO- https://downloads.datasance.com/datasance.gpg | tee /etc/apt/trusted.gpg.d/datasance.gpg >/dev/null\"\n            $sh_c \"echo 'deb [arch=all signed-by=/etc/apt/trusted.gpg.d/datasance.gpg] https://downloads.datasance.com/deb stable main' | tee /etc/apt/sources.list.d/datasance.list >/dev/null\"\n            $sh_c \"apt update -qy\"\n        ;;\n    esac\n}\n\ndo_install_wasm_shim() {\n    echo \"# Installing WebAssembly runtime support for $lsb_dist...\"\n    arch=$(uname -m)\n\n    # Normalize architecture for consistency\n    case \"$arch\" in\n        arm64|aarch64|armv7l|armv8) arch=\"aarch64\" ;;\n        amd64|x86_64) arch=\"x86_64\" ;;\n    esac\n\n    if [ \"$USE_PODMAN\" = \"true\" ]; then\n        case \"$lsb_dist\" in\n            fedora|centos|rhel|ol)\n                $sh_c \"yum install -y crun crun-wasm\"\n            ;;\n            sles|opensuse*)\n                $sh_c \"zypper install -y crun\"\n                # Note: crun-wasm might not be available in SUSE repos\n                # In that case, we'll need to use the standard crun\n            ;;\n        esac\n        \n    else\n        # Original containerd WASM shim installation for Docker\n        case \"$lsb_dist\" in\n            debian|raspbian|ubuntu)\n                $sh_c \"apt update -qy\" || { echo \"Failed to update apt packages\"; exit 1; }\n\n                if [ \"$arch\" = \"aarch64\" ]; then\n                    $sh_c \"apt install -qy containerd-shim-wasmedge-v1-aarch64-linux-gnu\"\n                    $sh_c \"apt install -qy containerd-shim-wasmer-v1-aarch64-linux-gnu\"\n                    $sh_c \"apt install -qy containerd-shim-wasmtime-v1-aarch64-linux-gnu\"\n                elif [ \"$arch\" = \"x86_64\" ]; then\n                    $sh_c \"apt install -qy containerd-shim-wasmedge-v1-x86-64-linux-gnu\"\n                    $sh_c \"apt install -qy containerd-shim-wasmer-v1-x86-64-linux-gnu\"\n                    $sh_c \"apt install -qy containerd-shim-wasmtime-v1-x86-64-linux-gnu\"\n                else\n                    echo \"Unsupported architecture: $arch for $lsb_dist\"\n                    exit 1\n                fi\n            ;;\n            *)\n                echo \"Unsupported OS: $lsb_dist\"\n                exit 1\n            ;;\n        esac\n    fi\n}\n\ndo_install_container_engine() {\n    if [ \"$USE_PODMAN\" = \"true\" ]; then\n        echo \"# Installing Podman and related packages...\"\n        case \"$lsb_dist\" in\n            fedora|centos|rhel|ol)\n                $sh_c \"yum install -y podman crun podman-docker\"\n            ;;\n            sles|opensuse*)\n                $sh_c \"zypper install -y podman crun podman-docker\"\n            ;;\n        esac\n        \n        # Modify daemon and enable podman services\n\t\tdo_modify_daemon\n        return\n    fi\n    \n    # Docker installation for Debian-based systems only\n    if [ \"$USE_PODMAN\" = \"false\" ] && command_exists docker; then\n        docker_version=$(docker -v | sed 's/.*version \\(.*\\),.*/\\1/' | tr -d '.')\n        if [ \"$docker_version\" -ge 2500 ]; then\n            echo \"# Docker $docker_version already installed\"\n            start_docker\n            do_modify_daemon\n            return\n        fi\n    fi\n    \n    echo \"# Installing Docker...\"\n    case \"$lsb_dist\" in\n        debian|ubuntu|raspbian)\n            case \"$dist_version\" in\n                \"stretch\")\n                    $sh_c \"apt install -y apt-transport-https ca-certificates curl gnupg2 software-properties-common\"\n                    curl -fsSL https://download.docker.com/linux/debian/gpg | $sh_c \"apt-key add -\"\n                    $sh_c \"add-apt-repository \\\"deb [arch=$(dpkg --print-architecture)] https://download.docker.com/linux/debian $(lsb_release -cs) stable\\\"\"\n                    $sh_c \"apt update -y\"\n                    $sh_c \"apt install -y docker-ce\"\n                ;;\n                *)\n                    curl -fsSL https://get.docker.com/ | $sh_c \"sh\"\n                ;;\n            esac\n        ;;\n        *)\n            curl -fsSL https://get.docker.com/ | $sh_c \"sh\"\n        ;;\n    esac\n    \n    if ! command_exists docker; then\n        echo \"Failed to install Docker\"\n        exit 1\n    fi\n    start_docker\n    do_modify_daemon\n}\n\n# Check if we should use Podman based on distribution\ndetermine_container_engine() {\n    USE_PODMAN=\"false\"\n    case \"$lsb_dist\" in\n        fedora|centos|rhel|ol|sles|opensuse*)\n            USE_PODMAN=\"true\"\n            echo \"# Using Podman for $lsb_dist\"\n        ;;\n        *)\n            echo \"# Using Docker for $lsb_dist\"\n        ;;\n    esac\n}\n\n# Source init.sh to get distribution info\n. /etc/iofog/agent/init.sh\ninit\n\n# Configure container engine based on distribution\ndetermine_container_engine\n\n# Install appropriate container engine\ndo_install_container_engine\n\n# Set up Datasance repository\ndo_set_datasance_repo\n\n# Install WebAssembly runtime support\ndo_install_wasm_shim\n\necho \"# Installation completed successfully\""),
	}
	file7 := &embedded.EmbeddedFile{
		Filename:    "agent/install_iofog.sh",
		FileModTime: time.Unix(1752322344, 0),

		Content: string("#!/bin/sh\nset -x\nset -e\n\ndo_check_install() {\n\tif command_exists iofog-agent; then\n\t\tlocal VERSION=$(sudo iofog-agent version | head -n1 | sed \"s/ioFog//g\" | tr -d ' ' | tr -d \"\\n\")\n\t\tif [ \"$VERSION\" = \"$agent_version\" ]; then\n\t\t\techo \"Agent $VERSION already installed.\"\n\t\t\texit 0\n\t\tfi\n\tfi\n}\n\ndo_stop_iofog() {\n\tif command_exists iofog-agent; then\n\t\tsudo systemctl stop iofog-agent\n\tfi\n}\n\n# do_check_iofog_on_arm() {\n#   if [ \"$lsb_dist\" = \"raspbian\" ] || [ \"$(uname -m)\" = \"armv7l\" ] || [ \"$(uname -m)\" = \"aarch64\" ] || [ \"$(uname -m)\" = \"armv8\" ]; then\n#     echo \"# We re on ARM ($(uname -m)) : Updating config.xml to use correct docker_url\"\n#     $sh_c 'sed -i -e \"s|<docker_url>.*</docker_url>|<docker_url>tcp://127.0.0.1:2375/</docker_url>|g\" /etc/iofog-agent/config.xml'\n\n#     echo \"# Restarting iofog-agent service\"\n#     $sh_c \"systemctl stop iofog-agent\"\n#     sleep 3\n#     $sh_c \"systemctl start iofog-agent\"\n#  fi\n# }\n\ndo_install_iofog() {\n\tAGENT_CONFIG_FOLDER=/etc/iofog-agent\n\tSAVED_AGENT_CONFIG_FOLDER=/tmp/agent-config-save\n\techo \"# Installing ioFog agent...\"\n\n\t# Save iofog-agent config\n\tif [ -d ${AGENT_CONFIG_FOLDER} ]; then\n\t\tsudo rm -rf ${SAVED_AGENT_CONFIG_FOLDER}\n\t\tsudo mkdir -p ${SAVED_AGENT_CONFIG_FOLDER}\n\t\tsudo cp -r ${AGENT_CONFIG_FOLDER}/* ${SAVED_AGENT_CONFIG_FOLDER}/\n\tfi\n\n\techo $lsb_dist\n\tcase \"$lsb_dist\" in\n\t\tfedora|rhel|ol|centos)\n\t\t\t$sh_c \"yum update -y\"\n\t\t\t$sh_c \"yum install -y iofog-agent-$agent_version-1.noarch\"\n\t\t\t;;\n\t\tsles|opensuse)\n\t\t\t$sh_c \"zypper refresh\"\n\t\t\t$sh_c \"zypper install -y iofog-agent=$agent_version\"\n\t\t\t;;\n\t\t*)\n\t\t\t$sh_c \"apt update -qy\"\n\t\t\t$sh_c \"apt install --allow-downgrades iofog-agent=$agent_version -qy\"\n\t\t\t;;\n\tesac\n\n\t# Restore iofog-agent config\n\tif [ -d ${SAVED_AGENT_CONFIG_FOLDER} ]; then\n\t\tsudo mv ${SAVED_AGENT_CONFIG_FOLDER}/* ${AGENT_CONFIG_FOLDER}/\n\t\tsudo rmdir ${SAVED_AGENT_CONFIG_FOLDER}\n\tfi\n\tsudo chmod 775 ${AGENT_CONFIG_FOLDER}\n}\n\ndo_start_iofog(){\n\n\tsudo systemctl start iofog-agent > /dev/null 2&>1 &\n\tlocal STATUS=\"\"\n\tlocal ITER=0\n\twhile [ \"$STATUS\" != \"RUNNING\" ] ; do\n    ITER=$((ITER+1))\n    if [ \"$ITER\" -gt 600 ]; then\n      echo 'Timed out waiting for Agent to be RUNNING'\n      exit 1;\n    fi\n    sleep 1\n    STATUS=$(sudo iofog-agent status | cut -f2 -d: | head -n 1 | tr -d '[:space:]')\n    echo \"${STATUS}\"\n\tdone\n\tsudo iofog-agent \"config -cf 10 -sf 10\"\n}\n\nagent_version=\"$1\"\necho \"Using variables\"\necho \"version: $agent_version\"\n\n. /etc/iofog/agent/init.sh\ninit\ndo_check_install\ndo_stop_iofog\ndo_install_iofog\ndo_start_iofog"),
	}
	file8 := &embedded.EmbeddedFile{
		Filename:    "agent/install_java.sh",
		FileModTime: time.Unix(1744129259, 0),

		Content: string("#!/bin/sh\nset -x\nset -e\n\njava_major_version=0\njava_minor_version=0\ndo_check_install() {\n\tif command_exists java; then\n        java_major_version=\"$(java --version | head -n1 | awk '{print $2}' | cut -d. -f1)\"\n        java_minor_version=\"$(java --version | head -n1 | awk '{print $2}' | cut -d. -f2)\"\n\tfi\n\tif [ \"$java_major_version\" -ge \"17\" ]  && [ \"$java_minor_version\" -ge \"0\" ]; then\n\t\techo \"Java $java_major_version.$java_minor_version  already installed.\"\n\t\texit 0\n\tfi\n}\n\ndo_install_java() {\n\techo \"# Installing java 17...\"\n\techo \"\"\n\tos_arch=$(getconf LONG_BIT)\n\tis_arm=\"\"\n\tif [ \"$lsb_dist\" = \"raspbian\" ] || [ \"$(uname -m)\" = \"armv7l\" ] || [ \"$(uname -m)\" = \"aarch64\" ] || [ \"$(uname -m)\" = \"armv8\" ]; then\n\t\tis_arm=\"-arm\"\n\tfi\n\tcase \"$lsb_dist\" in\n\t\tubuntu|debian|raspbian|mendel)\n\t\t\t$sh_c \"apt-get update -y\"\n\t\t\t$sh_c \"apt install -y openjdk-17-jdk\"\n\t\t;;\n\t\tfedora|centos|rhel|ol)\n\t\t\t$sh_c \"yum install -y java-17-openjdk\"\n\t\t;;\n\t\tsles|opensuse*)\n\t\t\t$sh_c \"zypper refresh\"\n\t\t\t$sh_c \"zypper install -y java-17-openjdk\"\n\t\t;;\n\t\t*)\n\t\t\techo \"Unsupported distribution: $lsb_dist\"\n\t\t\texit 1\n\t\t;;\n\tesac\n}\n\ndo_install_deps() {\n\tlocal installer=\"\"\n\tcase \"$lsb_dist\" in\n\t\tubuntu|debian|raspbian|mendel)\n\t\t\tinstaller=\"apt\"\n\t\t;;\n\t\tfedora|centos|rhel|ol)\n\t\t\tinstaller=\"yum\"\n\t\t;;\n\t\tsles|opensuse*)\n\t\t\tinstaller=\"zypper\"\n\t\t;;\n\t\t*)\n\t\t\techo \"Unsupported distribution: $lsb_dist\"\n\t\t\texit 1\n\t\t;;\n\tesac\n\n\tlocal iter=0\n\twhile ! $sh_c \"$installer update\" && [ \"$iter\" -lt 6 ]; do\n\t\tsleep 5\n\t\titer=$((iter+1))\n\tdone\n}\n\n. /etc/iofog/agent/init.sh\ninit\ndo_check_install\ndo_install_deps\ndo_install_java"),
	}
	file9 := &embedded.EmbeddedFile{
		Filename:    "agent/uninstall_iofog.sh",
		FileModTime: time.Unix(1744130024, 0),

		Content: string("#!/bin/sh\nset -x\nset -e\n\nAGENT_CONFIG_FOLDER=/etc/iofog-agent/\nAGENT_LOG_FOLDER=/var/log/iofog-agent/\n\ndo_uninstall_iofog() {\n\techo \"# Removing ioFog agent...\"\n\n\tcase \"$lsb_dist\" in\n\t\tubuntu|debian|raspbian)\n\t\t\t$sh_c \"apt-get -y --purge autoremove iofog-agent\"\n\t\t\t;;\n\t\tfedora|centos|rhel|ol)\n\t\t\t$sh_c \"yum remove -y iofog-agent\"\n\t\t\t;;\n\t\tsles|opensuse)\n\t\t\t$sh_c \"zypper remove -y iofog-agent\"\n\t\t\t;;\n\t\t*)\n\t\t\techo \"Error: Unsupported Linux distribution: $lsb_dist\"\n\t\t\texit 1\n\t\t\t;;\n\tesac\n\n\t# Remove config files\n\t$sh_c \"rm -rf ${AGENT_CONFIG_FOLDER}\"\n\n\t# Remove log files\n\t$sh_c \"rm -rf ${AGENT_LOG_FOLDER}\"\n}\n\n. /etc/iofog/agent/init.sh\ninit\n\ndo_uninstall_iofog"),
	}
	fileb := &embedded.EmbeddedFile{
		Filename:    "container-agent/check_prereqs.sh",
		FileModTime: time.Unix(1738603394, 0),

		Content: string("#!/bin/sh\nset -x\n\n# Check can sudo without password\nif ! $(sudo ls /tmp/ > /dev/null); then\n\tMSG=\"Unable to successfully use sudo with user $USER on this host.\\nUser $USER must be in sudoers group and using sudo without password must be enabled.\\nPlease see iofog.org documentation for more details.\"\n\techo $MSG\n\texit 1\nfi\n"),
	}
	filec := &embedded.EmbeddedFile{
		Filename:    "container-agent/init.sh",
		FileModTime: time.Unix(1744129930, 0),

		Content: string("#!/bin/sh\n# Script to detect Linux distribution and version\n# Used as a precursor for system-specific installations\n\n# Exit on error and print commands for debugging\nset -e\nset -x\n\n# Define user variable\nuser=\"$(id -un 2>/dev/null || true)\"\n\n# Check if a command exists\ncommand_exists() {\n    command -v \"$@\" > /dev/null 2>&1\n}\n\n# Detect the Linux distribution\nget_distribution() {\n    lsb_dist=\"\"\n    dist_version=\"\"\n    \n    # Every system that we officially support has /etc/os-release\n    if [ -r /etc/os-release ]; then\n        \n        lsb_dist=\"$(. /etc/os-release && echo \"$ID\")\"\n        \n        dist_version=\"$(. /etc/os-release && echo \"$VERSION_ID\")\"\n        lsb_dist=\"$(echo \"$lsb_dist\" | tr '[:upper:]' '[:lower:]')\"\n    else\n        echo \"Error: Unsupported Linux distribution! /etc/os-release not found.\"\n        exit 1\n    fi\n    \n    echo \"# Detected distribution: $lsb_dist (version: $dist_version)\"\n}\n\n# Check if this is a forked Linux distro\ncheck_forked() {\n    # Skip if lsb_release doesn't exist\n    if ! command_exists lsb_release; then\n        return\n    fi\n    \n    # Check if the `-u` option is supported\n    set +e\n    lsb_release -a > /dev/null 2>&1\n    lsb_release_exit_code=$?\n    set -e\n\n    # Check if the command has exited successfully, it means we're in a forked distro\n    if [ \"$lsb_release_exit_code\" = \"0\" ]; then\n        # Get the upstream release info\n        current_lsb_dist=$(lsb_release -a 2>&1 | tr '[:upper:]' '[:lower:]' | grep -E 'id' | cut -d ':' -f 2 | tr -d '[:space:]')\n        current_dist_version=$(lsb_release -a 2>&1 | tr '[:upper:]' '[:lower:]' | grep -E 'codename' | cut -d ':' -f 2 | tr -d '[:space:]')\n\n        # Print info about current distro\n        echo \"You're using '$current_lsb_dist' version '$current_dist_version'.\"\n        \n        # Check if current is different from detected (indicating a fork)\n        if [ \"$current_lsb_dist\" != \"$lsb_dist\" ] || [ \"$current_dist_version\" != \"$dist_version\" ]; then\n            echo \"Upstream release is '$lsb_dist' version '$dist_version'.\"\n        fi\n    else\n        # Additional checks for specific distros that might not be properly detected\n        if [ -r /etc/debian_version ] && [ \"$lsb_dist\" != \"ubuntu\" ] && [ \"$lsb_dist\" != \"raspbian\" ]; then\n            if [ \"$lsb_dist\" = \"osmc\" ]; then\n                # OSMC runs Raspbian\n                lsb_dist=raspbian\n            else\n                # We're Debian and don't even know it!\n                lsb_dist=debian\n            fi\n            # Get Debian version and map it to codename\n            dist_version=\"$(sed 's/\\/.*//' /etc/debian_version | sed 's/\\..*//')\"\n            case \"$dist_version\" in\n                14)\n                    dist_version=\"forky\"\n                ;;\n                13)\n                    dist_version=\"trixie\"\n                ;;\n                12)\n                    dist_version=\"bookworm\"\n                ;;\n                11)\n                    dist_version=\"bullseye\"\n                ;;\n                10)\n                    dist_version=\"buster\"\n                ;;\n                9)\n                    dist_version=\"stretch\"\n                ;;\n                8|'Kali Linux 2')\n                    dist_version=\"jessie\"\n                ;;\n                7)\n                    dist_version=\"wheezy\"\n                ;;\n            esac\n        elif [ -r /etc/redhat-release ] && [ -z \"$lsb_dist\" ]; then\n            lsb_dist=redhat\n            # Extract version from redhat-release file\n            dist_version=\"$(sed 's/.*release \\([0-9.]*\\).*/\\1/' /etc/redhat-release)\"\n        fi\n    fi\n}\n\n# Set up sudo command if necessary\nsetup_sudo() {\n    sh_c='sh -c'\n    if [ \"$user\" != 'root' ]; then\n        if command_exists sudo; then\n            sh_c='sudo -E sh -c'\n        elif command_exists su; then\n            sh_c='su -c'\n        else\n            echo \"Error: this installer needs the ability to run commands as root.\"\n            echo \"We are unable to find either 'sudo' or 'su' available to make this happen.\"\n            exit 1\n        fi\n    fi\n    echo \"# Using command executor: $sh_c\"\n}\n\n# Refine distribution version detection based on the distro\nrefine_distribution_version() {\n    case \"$lsb_dist\" in\n        ubuntu)\n            if command_exists lsb_release; then\n                dist_version=\"$(lsb_release --codename | cut -f2)\"\n            fi\n            if [ -z \"$dist_version\" ] && [ -r /etc/lsb-release ]; then\n                \n                dist_version=\"$(. /etc/lsb-release && echo \"$DISTRIB_CODENAME\")\"\n            fi\n        ;;\n\n        debian|raspbian)\n            # If we only have a number, map it to a codename for better recognition\n            if echo \"$dist_version\" | grep -qE '^[0-9]+$'; then\n                case \"$dist_version\" in\n                    14)\n                        dist_version=\"forky\"\n                    ;;\n                    13)\n                        dist_version=\"trixie\"\n                    ;;\n                    12)\n                        dist_version=\"bookworm\"\n                    ;;\n                    11)\n                        dist_version=\"bullseye\"\n                    ;;\n                    10)\n                        # Handle special case for Buster\n                        dist_version=\"buster\"\n                        if [ \"$user\" = 'root' ]; then\n                            apt-get update --allow-releaseinfo-change || true\n                        elif command_exists sudo; then\n                            sudo apt-get update --allow-releaseinfo-change || true\n                        fi\n                    ;;\n                    9)\n                        dist_version=\"stretch\"\n                    ;;\n                    8)\n                        dist_version=\"jessie\"\n                    ;;\n                    7)\n                        dist_version=\"wheezy\"\n                    ;;\n                esac\n            fi\n        ;;\n\n        centos|rhel|fedora|ol)\n            # Make sure we have a version number\n            if [ -z \"$dist_version\" ] && [ -r /etc/os-release ]; then\n                \n                dist_version=\"$(. /etc/os-release && echo \"$VERSION_ID\")\"\n            fi\n            if [ -z \"$dist_version\" ] && [ -r /etc/redhat-release ]; then\n                dist_version=\"$(sed 's/.*release \\([0-9.]*\\).*/\\1/' /etc/redhat-release)\"\n            fi\n        ;;\n\n        sles|opensuse)\n            if [ -z \"$dist_version\" ] && [ -r /etc/os-release ]; then\n                dist_version=\"$(. /etc/os-release && echo \"$VERSION_ID\")\"\n            fi\n            # Fallback for older versions\n            if [ -z \"$dist_version\" ] && [ -r /etc/SuSE-release ]; then\n                dist_version=\"$(grep VERSION /etc/SuSE-release | sed 's/^VERSION = //')\"\n            fi\n            # Ensure version is in the correct format (e.g., 15.4 for SLES 15 SP4)\n            if [ -n \"$dist_version\" ]; then\n                # Remove any non-numeric characters except dots\n                dist_version=\"$(echo \"$dist_version\" | sed 's/[^0-9.]//g')\"\n            fi\n            # Normalize distribution name\n            if [ \"$lsb_dist\" = \"sles\" ]; then\n                lsb_dist=\"sles\"\n            elif [ \"$lsb_dist\" = \"opensuse\" ]; then\n                lsb_dist=\"opensuse\"\n            fi\n        ;;\n\n        *)\n            if command_exists lsb_release; then\n                dist_version=\"$(lsb_release --release | cut -f2)\"\n            fi\n            if [ -z \"$dist_version\" ] && [ -r /etc/os-release ]; then\n                \n                dist_version=\"$(. /etc/os-release && echo \"$VERSION_ID\")\"\n            fi\n        ;;\n    esac\n}\n\n# Init function\ninit() {\n    # Detect basic distribution info\n    get_distribution\n    \n    # Set up sudo for privileged commands\n    setup_sudo\n    \n    # Refine version information\n    refine_distribution_version\n    \n    # Check if this is a forked distro\n    check_forked\n    \n    # Print final distribution information\n    echo \"----------------------------------------\"\n    echo \"Linux Distribution: $lsb_dist\"\n    echo \"Version: $dist_version\"\n    echo \"----------------------------------------\"\n    \n}\n"),
	}
	filed := &embedded.EmbeddedFile{
		Filename:    "container-agent/install_deps.sh",
		FileModTime: time.Unix(1738603394, 0),

		Content: string("#!/bin/sh\nset -x\nset -e\n\n\n/etc/iofog/agent/install_docker.sh\n"),
	}
	filee := &embedded.EmbeddedFile{
		Filename:    "container-agent/install_docker.sh",
		FileModTime: time.Unix(1744129949, 0),

		Content: string("#!/bin/sh\n# Script to install Docker/Podman based on Linux distribution\n# Sources init.sh for distribution detection\n\nset -x\nset -e\n\nstart_docker() {\n    set +e\n    # check if docker is running\n    if ! $sh_c \"docker ps\" >/dev/null 2>&1; then\n        # Try init.d\n        $sh_c \"/etc/init.d/docker start\" >/dev/null 2>&1\n        local err_code=$?\n        # Try systemd\n        if [ $err_code -ne 0 ]; then\n            $sh_c \"systemctl start docker\" >/dev/null 2>&1\n            err_code=$?\n        fi\n        # Try service\n        if [ $err_code -ne 0 ]; then\n            $sh_c \"service docker start\" >/dev/null 2>&1\n            err_code=$?\n        fi\n        # Try snapd\n        if [ $err_code -ne 0 ]; then\n            $sh_c \"snap start docker\" >/dev/null 2>&1\n            err_code=$?\n        fi\n        if [ $err_code -ne 0 ]; then\n            echo \"Could not start Docker daemon\"\n            exit 1\n        fi\n    fi\n    set -e\n}\n\n\ndo_modify_daemon() {\n    # Skip for Podman installations\n    if [ \"$USE_PODMAN\" = \"true\" ]; then\n        echo \"# Configuring Podman for CDI directory support...\"\n\n        # Create CDI directories\n        $sh_c \"mkdir -p /etc/cdi /var/run/cdi\"\n\n        # Ensure /etc/containers exists\n        $sh_c \"mkdir -p /etc/containers\"\n\n        # Create containers.conf if it doesn't exist\n        if [ ! -f \"/etc/containers/containers.conf\" ]; then\n            $sh_c 'cat > /etc/containers/containers.conf <<EOF\n[engine]\nruntime = \"crun\"\ncdi_spec_dirs = [\"/etc/cdi\", \"/var/run/cdi\"]\nEOF'\n        else\n            # Check if [engine] block exists\n            if grep -q \"^\\[engine\\]\" /etc/containers/containers.conf; then\n                # Ensure runtime is set under [engine]\n                if grep -q \"^runtime\" /etc/containers/containers.conf; then\n                    $sh_c \"sed -i 's|^runtime *=.*|runtime = \\\"crun\\\"|' /etc/containers/containers.conf\"\n                else\n                    $sh_c \"sed -i '/^\\[engine\\]/a runtime = \\\"crun\\\"' /etc/containers/containers.conf\"\n                fi\n\n                # Ensure cdi_spec_dirs is set under [engine]\n                if grep -q \"^cdi_spec_dirs\" /etc/containers/containers.conf; then\n                    $sh_c \"sed -i 's|^cdi_spec_dirs *=.*|cdi_spec_dirs = [\\\"/etc/cdi\\\", \\\"/var/run/cdi\\\"]|' /etc/containers/containers.conf\"\n                else\n                    $sh_c \"sed -i '/^\\[engine\\]/a cdi_spec_dirs = [\\\"/etc/cdi\\\", \\\"/var/run/cdi\\\"]' /etc/containers/containers.conf\"\n                fi\n            else\n                # Append full engine block if missing\n                $sh_c 'echo -e \"\\n[engine]\\nruntime = \\\"crun\\\"\\ncdi_spec_dirs = [\\\"/etc/cdi\\\", \\\"/var/run/cdi\\\"]\" >> /etc/containers/containers.conf'\n            fi\n        fi\n\n        # Enable and start Podman services\n        $sh_c \"systemctl enable podman\"\n        $sh_c \"systemctl start podman\"\n        $sh_c \"systemctl enable podman.socket\"\n        $sh_c \"systemctl start podman.socket\"\n        return\n    fi\n    \n    # Original Docker daemon configuration\n    if [ ! -f /etc/docker/daemon.json ]; then\n        echo \"Creating /etc/docker/daemon.json...\"\n        $sh_c \"mkdir -p /etc/docker\"\n        $sh_c 'cat > /etc/docker/daemon.json << EOF\n{\n\t\"storage-driver\": \"overlayfs\",\n    \"features\": {\n        \"containerd-snapshotter\": true,\n        \"cdi\": true\n    },\n    \"cdi-spec-dirs\": [\"/etc/cdi/\", \"/var/run/cdi\"]\n}\nEOF'\n    else\n        echo \"/etc/docker/daemon.json already exists\"\n    fi\n    echo \"Restarting Docker daemon...\"\n    $sh_c \"systemctl daemon-reload\"\n    $sh_c \"systemctl restart docker\"\n}\n\ndo_set_datasance_repo() {\n    echo \"# Setting up Datasance repository for $lsb_dist...\"\n    \n    case \"$lsb_dist\" in\n        fedora|centos|rhel|ol|sles|opensuse*)\n            # RPM-based distros\n            $sh_c \"cd /etc/yum.repos.d && curl -s https://downloads.datasance.com/datasance.repo -LO\"\n            if [ \"$lsb_dist\" = \"fedora\" ] || [ \"$lsb_dist\" = \"centos\" ] || [ \"$lsb_dist\" = \"rhel\" ] || [ \"$lsb_dist\" = \"ol\" ]; then\n                $sh_c \"yum update -y\"\n            else\n                $sh_c \"zypper refresh\"\n            fi\n        ;;\n        debian|ubuntu|raspbian|*)\n            # DEB-based distros\n            $sh_c \"apt update -qy\"\n            $sh_c \"apt install -qy debian-archive-keyring apt-transport-https\"\n            $sh_c \"wget -qO- https://downloads.datasance.com/datasance.gpg | tee /etc/apt/trusted.gpg.d/datasance.gpg >/dev/null\"\n            $sh_c \"echo 'deb [arch=all signed-by=/etc/apt/trusted.gpg.d/datasance.gpg] https://downloads.datasance.com/deb stable main' | tee /etc/apt/sources.list.d/datasance.list >/dev/null\"\n            $sh_c \"apt update -qy\"\n        ;;\n    esac\n}\n\ndo_install_wasm_shim() {\n    echo \"# Installing WebAssembly runtime support for $lsb_dist...\"\n    arch=$(uname -m)\n\n    # Normalize architecture for consistency\n    case \"$arch\" in\n        arm64|aarch64|armv7l|armv8) arch=\"aarch64\" ;;\n        amd64|x86_64) arch=\"x86_64\" ;;\n    esac\n\n    if [ \"$USE_PODMAN\" = \"true\" ]; then\n        case \"$lsb_dist\" in\n            fedora|centos|rhel|ol)\n                $sh_c \"yum install -y crun crun-wasm\"\n            ;;\n            sles|opensuse*)\n                $sh_c \"zypper install -y crun\"\n                # Note: crun-wasm might not be available in SUSE repos\n                # In that case, we'll need to use the standard crun\n            ;;\n        esac\n        \n    else\n        # Original containerd WASM shim installation for Docker\n        case \"$lsb_dist\" in\n            debian|raspbian|ubuntu)\n                $sh_c \"apt update -qy\" || { echo \"Failed to update apt packages\"; exit 1; }\n\n                if [ \"$arch\" = \"aarch64\" ]; then\n                    $sh_c \"apt install -qy containerd-shim-wasmedge-v1-aarch64-linux-gnu\"\n                    $sh_c \"apt install -qy containerd-shim-wasmer-v1-aarch64-linux-gnu\"\n                    $sh_c \"apt install -qy containerd-shim-wasmtime-v1-aarch64-linux-gnu\"\n                elif [ \"$arch\" = \"x86_64\" ]; then\n                    $sh_c \"apt install -qy containerd-shim-wasmedge-v1-x86-64-linux-gnu\"\n                    $sh_c \"apt install -qy containerd-shim-wasmer-v1-x86-64-linux-gnu\"\n                    $sh_c \"apt install -qy containerd-shim-wasmtime-v1-x86-64-linux-gnu\"\n                else\n                    echo \"Unsupported architecture: $arch for $lsb_dist\"\n                    exit 1\n                fi\n            ;;\n            *)\n                echo \"Unsupported OS: $lsb_dist\"\n                exit 1\n            ;;\n        esac\n    fi\n}\n\ndo_install_container_engine() {\n    if [ \"$USE_PODMAN\" = \"true\" ]; then\n        echo \"# Installing Podman and related packages...\"\n        case \"$lsb_dist\" in\n            fedora|centos|rhel|ol)\n                $sh_c \"yum install -y podman crun podman-docker\"\n            ;;\n            sles|opensuse*)\n                $sh_c \"zypper install -y podman crun podman-docker\"\n            ;;\n        esac\n        \n        # Modify daemon and enable podman services\n\t\tdo_modify_daemon\n        return\n    fi\n    \n    # Docker installation for Debian-based systems only\n    if [ \"$USE_PODMAN\" = \"false\" ] && command_exists docker; then\n        docker_version=$(docker -v | sed 's/.*version \\(.*\\),.*/\\1/' | tr -d '.')\n        if [ \"$docker_version\" -ge 2500 ]; then\n            echo \"# Docker $docker_version already installed\"\n            start_docker\n            do_modify_daemon\n            return\n        fi\n    fi\n    \n    echo \"# Installing Docker...\"\n    case \"$lsb_dist\" in\n        debian|ubuntu|raspbian)\n            case \"$dist_version\" in\n                \"stretch\")\n                    $sh_c \"apt install -y apt-transport-https ca-certificates curl gnupg2 software-properties-common\"\n                    curl -fsSL https://download.docker.com/linux/debian/gpg | $sh_c \"apt-key add -\"\n                    $sh_c \"add-apt-repository \\\"deb [arch=$(dpkg --print-architecture)] https://download.docker.com/linux/debian $(lsb_release -cs) stable\\\"\"\n                    $sh_c \"apt update -y\"\n                    $sh_c \"apt install -y docker-ce\"\n                ;;\n                *)\n                    curl -fsSL https://get.docker.com/ | $sh_c \"sh\"\n                ;;\n            esac\n        ;;\n        *)\n            curl -fsSL https://get.docker.com/ | $sh_c \"sh\"\n        ;;\n    esac\n    \n    if ! command_exists docker; then\n        echo \"Failed to install Docker\"\n        exit 1\n    fi\n    start_docker\n    do_modify_daemon\n}\n\n# Check if we should use Podman based on distribution\ndetermine_container_engine() {\n    USE_PODMAN=\"false\"\n    case \"$lsb_dist\" in\n        fedora|centos|rhel|ol|sles|opensuse*)\n            USE_PODMAN=\"true\"\n            echo \"# Using Podman for $lsb_dist\"\n        ;;\n        *)\n            echo \"# Using Docker for $lsb_dist\"\n        ;;\n    esac\n}\n\n# Source init.sh to get distribution info\n. /etc/iofog/agent/init.sh\ninit\n\n# Configure container engine based on distribution\ndetermine_container_engine\n\n# Install appropriate container engine\ndo_install_container_engine\n\n# Set up Datasance repository\ndo_set_datasance_repo\n\n# Install WebAssembly runtime support\ndo_install_wasm_shim\n\necho \"# Installation completed successfully\""),
	}
	filef := &embedded.EmbeddedFile{
		Filename:    "container-agent/install_iofog.sh",
		FileModTime: time.Unix(1752322344, 0),

		Content: string("#!/bin/sh\nset -x\nset -e\n\nAGENT_LOG_FOLDER=/var/log/iofog-agent\nAGENT_BACKUP_FOLDER=/var/backups/iofog-agent\nAGENT_MESSAGE_FOLDER=/var/lib/iofog-agent\nAGENT_SHARE_FOLDER=/usr/share/iofog-agent\nSAVED_AGENT_CONFIG_FOLDER=/tmp/agent-config-save\nAGENT_CONTAINER_NAME=\"iofog-agent\"\nETC_DIR=/etc/iofog/agent\n\ndo_check_install() {\n\tif command_exists iofog-agent; then\n\t\tlocal VERSION=$(sudo iofog-agent version | head -n1 | sed \"s/ioFog//g\" | tr -d ' ' | tr -d \"\\n\")\n\t\tif [ \"$VERSION\" = \"$agent_version\" ]; then\n\t\t\techo \"Agent $VERSION already installed.\"\n\t\t\texit 0\n\t\tfi\n\tfi\n}\n\ndo_stop_iofog() {\n\tif command_exists iofog-agent; then\n\t\tsudo systemctl stop iofog-agent\n\tfi\n}\n\n# do_check_iofog_on_arm() {\n#   if [ \"$lsb_dist\" = \"raspbian\" ] || [ \"$(uname -m)\" = \"armv7l\" ] || [ \"$(uname -m)\" = \"aarch64\" ] || [ \"$(uname -m)\" = \"armv8\" ]; then\n#     echo \"# We re on ARM ($(uname -m)) : Updating config.xml to use correct docker_url\"\n#     $sh_c 'sed -i -e \"s|<docker_url>.*</docker_url>|<docker_url>tcp://127.0.0.1:2375/</docker_url>|g\" /etc/iofog-agent/config.xml'\n\n#     echo \"# Restarting iofog-agent service\"\n#     $sh_c \"systemctl stop iofog-agent\"\n#     sleep 3\n#     $sh_c \"systemctl start iofog-agent\"\n#  fi\n# }\n\ndo_create_env() {\nENV_FILE_NAME=iofog-agent.env # Used as an env file in systemd\n\nENV_FILE=\"$ETC_DIR/$ENV_FILE_NAME\"\n\n# Env file (for systemd)\nrm -f \"$ENV_FILE\"\ntouch \"$ENV_FILE\"\n\necho \"IOFOG_AGENT_IMAGE=${agent_image}\" >> \"$ENV_FILE\"\n\n\n}\n\ndo_install_iofog() {\n\techo \"# Installing ioFog agent...\"\n\t\n    # 1. Ensure folders exist\n    for FOLDER in ${ETC_DIR} ${AGENT_LOG_FOLDER} ${AGENT_BACKUP_FOLDER} ${AGENT_MESSAGE_FOLDER} ${AGENT_SHARE_FOLDER}; do\n        if [ ! -d \"$FOLDER\" ]; then\n            echo \"Creating folder: $FOLDER\"\n            sudo mkdir -p \"$FOLDER\"\n            sudo chmod 775 \"$FOLDER\"\n        fi\n    done\n\tdo_create_env\n\n    # Check if we're using Podman (RHEL, CentOS, Fedora, etc.)\n    if [ \"$lsb_dist\" = \"rhel\" ] || [ \"$lsb_dist\" = \"centos\" ] || [ \"$lsb_dist\" = \"fedora\" ] || [ \"$lsb_dist\" = \"ol\" ] || [ \"$lsb_dist\" = \"sles\" ] || [ \"$lsb_dist\" = \"opensuse\" ]; then\n        echo \"Using Podman for container management...\"\n        SYSTEMD_SERVICE_FILE=/etc/containers/systemd/iofog-agent.container\n\n        cat <<EOF | sudo tee ${SYSTEMD_SERVICE_FILE} > /dev/null\n[Unit]\nDescription=Datasance PoT IoFog Agent Service\nAfter=podman.service\nRequires=podman.service\n\n[Container]\nContainerName=${AGENT_CONTAINER_NAME}\nImage=${agent_image}\nPodmanArgs=--privileged --stop-timeout=60\nEnvironmentFile=${ETC_DIR}/iofog-agent.env\nNetwork=host\nVolume=/run/podman/podman.sock:/run/podman/podman.sock:rw\nVolume=iofog-agent-config:/etc/iofog-agent:rw\nVolume=/var/log/iofog-agent:/var/log/iofog-agent:rw\nVolume=/var/backups/iofog-agent:/var/backups/iofog-agent:rw\nVolume=/usr/share/iofog-agent:/usr/share/iofog-agent:rw\nVolume=/var/lib/iofog-agent:/var/lib/iofog-agent:rw\nLogDriver=journald\n\n[Service]\nRestart=always\n\n[Install]\nWantedBy=default.target\nEOF\n\n        # Reload systemd and enable the service\n        sudo systemctl daemon-reload\n        sudo systemctl restart podman\n        sudo systemctl start iofog-agent.service\n\n        # Create the iofog-agent executable script for Podman\n        EXECUTABLE_FILE=/usr/local/bin/iofog-agent\n        cat <<'EOF' | sudo tee ${EXECUTABLE_FILE} > /dev/null\n#!/bin/bash\nCONTAINER_NAME=\"iofog-agent\"\n\n# Check if the container is running\nif ! podman ps --format '{{.Names}}' | grep -q \"^${CONTAINER_NAME}$\"; then\n    echo \"Error: The iofog-agent container is not running.\"\n    exit 1\nfi\n\n# Execute the command in the container\npodman exec ${CONTAINER_NAME} iofog-agent \"$@\"\nEOF\n    else\n        # Docker-based installation (Debian, Ubuntu, etc.)\n        echo \"Using Docker for container management...\"\n        SYSTEMD_SERVICE_FILE=/etc/systemd/system/iofog-agent.service\n\n        cat <<EOF | sudo tee ${SYSTEMD_SERVICE_FILE} > /dev/null\n[Unit]\nDescription=Datasance PoT IoFog Agent Service\nAfter=docker.service\nRequires=docker.service\n\n[Service]\nTimeoutStartSec=0\nRestart=always\nExecStartPre=/usr/bin/docker pull ${agent_image} \nExecStartPre=-/usr/bin/docker rm -f ${AGENT_CONTAINER_NAME}\nExecStart=/usr/bin/docker run --rm --name ${AGENT_CONTAINER_NAME} \\\\\n--env-file ${ETC_DIR}/iofog-agent.env \\\\\n-v /var/run/docker.sock:/var/run/docker.sock:rw \\\\\n-v iofog-agent-config:/etc/iofog-agent:rw \\\\\n-v /var/log/iofog-agent:/var/log/iofog-agent:rw \\\\\n-v /var/backups/iofog-agent:/var/backups/iofog-agent:rw \\\\\n-v /usr/share/iofog-agent:/usr/share/iofog-agent:rw \\\\\n-v /var/lib/iofog-agent:/var/lib/iofog-agent:rw \\\\\n--net=host \\\\\n--privileged \\\\\n--stop-timeout 60 \\\\\n--attach stdout \\\\\n--attach stderr \\\\\n${agent_image}\nExecStop=/usr/bin/docker stop ${AGENT_CONTAINER_NAME}\n\n[Install]\nWantedBy=default.target\nEOF\n\n        # Reload systemd and enable the service\n        sudo systemctl daemon-reload\n        sudo systemctl enable iofog-agent.service\n\n        # Create the iofog-agent executable script for Docker\n        EXECUTABLE_FILE=/usr/local/bin/iofog-agent\n        cat <<'EOF' | sudo tee ${EXECUTABLE_FILE} > /dev/null\n#!/bin/bash\nCONTAINER_NAME=\"iofog-agent\"\n\n# Check if the container is running\nif ! docker ps --format '{{.Names}}' | grep -q \"^${CONTAINER_NAME}$\"; then\n    echo \"Error: The iofog-agent container is not running.\"\n    exit 1\nfi\n\n# Execute the command in the container\ndocker exec ${CONTAINER_NAME} iofog-agent \"$@\"\nEOF\n    fi\n\n    # Make the script executable\n    sudo chmod +x ${EXECUTABLE_FILE}\n\n    echo \"ioFog agent installation completed!\"\n}\n\ndo_start_iofog(){\n\tsudo systemctl start iofog-agent > /dev/null 2&>1 &\n\tlocal STATUS=\"\"\n\tlocal ITER=0\n\twhile [ \"$STATUS\" != \"RUNNING\" ] ; do\n    ITER=$((ITER+1))\n    if [ \"$ITER\" -gt 600 ]; then\n      echo 'Timed out waiting for Agent to be RUNNING'\n      exit 1;\n    fi\n    sleep 1\n    STATUS=$(sudo iofog-agent status | cut -f2 -d: | head -n 1 | tr -d '[:space:]')\n    echo \"${STATUS}\"\n\tdone\n\tsudo iofog-agent \"config -cf 10 -sf 10\"\n}\n\nagent_image=\"$1\"\necho \"Using variables\"\necho \"version: $agent_image\"\n\n. /etc/iofog/agent/init.sh\ninit\ndo_check_install\ndo_stop_iofog\ndo_install_iofog\ndo_start_iofog"),
	}
	fileg := &embedded.EmbeddedFile{
		Filename:    "container-agent/uninstall_iofog.sh",
		FileModTime: time.Unix(1744134610, 0),

		Content: string("#!/bin/sh\nset -x\nset -e\n\nAGENT_CONFIG_FOLDER=iofog-agent-config\nAGENT_LOG_FOLDER=/var/log/iofog-agent\nAGENT_BACKUP_FOLDER=/var/backups/iofog-agent\nAGENT_MESSAGE_FOLDER=/var/lib/iofog-agent\nEXECUTABLE_FILE=/usr/local/bin/iofog-agent\nCONTAINER_NAME=\"iofog-agent\"\n\ndo_uninstall_iofog() {\n    echo \"# Removing ioFog agent...\"\n\n    # Set the appropriate systemd service file based on the Linux distribution\n    if [ \"$lsb_dist\" = \"rhel\" ] || [ \"$lsb_dist\" = \"fedora\" ] || [ \"$lsb_dist\" = \"centos\" ] || [ \"$lsb_dist\" = \"ol\" ] || [ \"$lsb_dist\" = \"sles\" ] || [ \"$lsb_dist\" = \"opensuse\" ]; then\n        SYSTEMD_SERVICE_FILE=/etc/containers/systemd/iofog-agent.container\n        CONTAINER_RUNTIME=\"podman\"\n    else\n        SYSTEMD_SERVICE_FILE=/etc/systemd/system/iofog-agent.service\n        CONTAINER_RUNTIME=\"docker\"\n    fi\n\n    # Disable and stop the systemd service\n    if [ -f ${SYSTEMD_SERVICE_FILE} ]; then\n        echo \"Disabling and stopping the systemd service...\"\n        sudo systemctl stop iofog-agent.service || true\n        sudo systemctl disable iofog-agent.service || true\n        sudo rm -f ${SYSTEMD_SERVICE_FILE}\n        sudo systemctl daemon-reload\n    fi\n\n    # Remove the container\n    if ${CONTAINER_RUNTIME} ps --format '{{.Names}}' | grep -q \"^${CONTAINER_NAME}$\"; then\n        echo \"Stopping and removing the ioFog agent container...\"\n        ${CONTAINER_RUNTIME} stop ${CONTAINER_NAME}\n        ${CONTAINER_RUNTIME} rm ${CONTAINER_NAME}\n    fi\n\n    # Remove config files\n    echo \"Checking if the ${CONTAINER_RUNTIME} volume exists...\"\n\n    if sudo ${CONTAINER_RUNTIME} volume inspect \"${AGENT_CONFIG_FOLDER}\" >/dev/null 2>&1; then\n        echo \"${CONTAINER_RUNTIME} volume '${AGENT_CONFIG_FOLDER}' found. Removing...\"\n        sudo ${CONTAINER_RUNTIME} volume rm \"${AGENT_CONFIG_FOLDER}\"\n        echo \"${CONTAINER_RUNTIME} volume '${AGENT_CONFIG_FOLDER}' has been removed.\"\n    else\n        echo \"${CONTAINER_RUNTIME} volume '${AGENT_CONFIG_FOLDER}' does not exist. Skipping removal.\"\n    fi\n\n    # Remove log files\n    echo \"Removing log files...\"\n    sudo rm -rf ${AGENT_LOG_FOLDER}\n\n    # Remove backup files\n    echo \"Removing backup files...\"\n    sudo rm -rf ${AGENT_BACKUP_FOLDER}\n\n    # Remove message files\n    echo \"Removing message files...\"\n    sudo rm -rf ${AGENT_MESSAGE_FOLDER}\n\n    # Remove the executable script\n    if [ -f ${EXECUTABLE_FILE} ]; then\n        echo \"Removing the iofog-agent executable script...\"\n        sudo rm -f ${EXECUTABLE_FILE}\n    fi\n\n    echo \"ioFog agent uninstalled successfully!\"\n}\n\n. /etc/iofog/agent/init.sh\ninit\n\ndo_uninstall_iofog\n"),
	}
	filei := &embedded.EmbeddedFile{
		Filename:    "container-controller/check_prereqs.sh",
		FileModTime: time.Unix(1738603394, 0),

		Content: string("#!/bin/sh\nset -x\n\n# Check can sudo without password\nif ! $(sudo ls /tmp/ > /dev/null); then\n\tMSG=\"Unable to successfully use sudo with user $USER on this host.\\nUser $USER must be in sudoers group and using sudo without password must be enabled.\\nPlease see iofog.org documentation for more details.\"\n\techo $MSG\n\texit 1\nfi\n"),
	}
	filej := &embedded.EmbeddedFile{
		Filename:    "container-controller/init.sh",
		FileModTime: time.Unix(1744130151, 0),

		Content: string("#!/bin/sh\n# Script to detect Linux distribution and version\n# Used as a precursor for system-specific installations\n\n# Exit on error and print commands for debugging\nset -e\nset -x\n\n# Define user variable\nuser=\"$(id -un 2>/dev/null || true)\"\n\n# Check if a command exists\ncommand_exists() {\n    command -v \"$@\" > /dev/null 2>&1\n}\n\n# Detect the Linux distribution\nget_distribution() {\n    lsb_dist=\"\"\n    dist_version=\"\"\n    \n    # Every system that we officially support has /etc/os-release\n    if [ -r /etc/os-release ]; then\n        \n        lsb_dist=\"$(. /etc/os-release && echo \"$ID\")\"\n        \n        dist_version=\"$(. /etc/os-release && echo \"$VERSION_ID\")\"\n        lsb_dist=\"$(echo \"$lsb_dist\" | tr '[:upper:]' '[:lower:]')\"\n    else\n        echo \"Error: Unsupported Linux distribution! /etc/os-release not found.\"\n        exit 1\n    fi\n    \n    echo \"# Detected distribution: $lsb_dist (version: $dist_version)\"\n}\n\n# Check if this is a forked Linux distro\ncheck_forked() {\n    # Skip if lsb_release doesn't exist\n    if ! command_exists lsb_release; then\n        return\n    fi\n    \n    # Check if the `-u` option is supported\n    set +e\n    lsb_release -a > /dev/null 2>&1\n    lsb_release_exit_code=$?\n    set -e\n\n    # Check if the command has exited successfully, it means we're in a forked distro\n    if [ \"$lsb_release_exit_code\" = \"0\" ]; then\n        # Get the upstream release info\n        current_lsb_dist=$(lsb_release -a 2>&1 | tr '[:upper:]' '[:lower:]' | grep -E 'id' | cut -d ':' -f 2 | tr -d '[:space:]')\n        current_dist_version=$(lsb_release -a 2>&1 | tr '[:upper:]' '[:lower:]' | grep -E 'codename' | cut -d ':' -f 2 | tr -d '[:space:]')\n\n        # Print info about current distro\n        echo \"You're using '$current_lsb_dist' version '$current_dist_version'.\"\n        \n        # Check if current is different from detected (indicating a fork)\n        if [ \"$current_lsb_dist\" != \"$lsb_dist\" ] || [ \"$current_dist_version\" != \"$dist_version\" ]; then\n            echo \"Upstream release is '$lsb_dist' version '$dist_version'.\"\n        fi\n    else\n        # Additional checks for specific distros that might not be properly detected\n        if [ -r /etc/debian_version ] && [ \"$lsb_dist\" != \"ubuntu\" ] && [ \"$lsb_dist\" != \"raspbian\" ]; then\n            if [ \"$lsb_dist\" = \"osmc\" ]; then\n                # OSMC runs Raspbian\n                lsb_dist=raspbian\n            else\n                # We're Debian and don't even know it!\n                lsb_dist=debian\n            fi\n            # Get Debian version and map it to codename\n            dist_version=\"$(sed 's/\\/.*//' /etc/debian_version | sed 's/\\..*//')\"\n            case \"$dist_version\" in\n                14)\n                    dist_version=\"forky\"\n                ;;\n                13)\n                    dist_version=\"trixie\"\n                ;;\n                12)\n                    dist_version=\"bookworm\"\n                ;;\n                11)\n                    dist_version=\"bullseye\"\n                ;;\n                10)\n                    dist_version=\"buster\"\n                ;;\n                9)\n                    dist_version=\"stretch\"\n                ;;\n                8|'Kali Linux 2')\n                    dist_version=\"jessie\"\n                ;;\n                7)\n                    dist_version=\"wheezy\"\n                ;;\n            esac\n        elif [ -r /etc/redhat-release ] && [ -z \"$lsb_dist\" ]; then\n            lsb_dist=redhat\n            # Extract version from redhat-release file\n            dist_version=\"$(sed 's/.*release \\([0-9.]*\\).*/\\1/' /etc/redhat-release)\"\n        fi\n    fi\n}\n\n# Set up sudo command if necessary\nsetup_sudo() {\n    sh_c='sh -c'\n    if [ \"$user\" != 'root' ]; then\n        if command_exists sudo; then\n            sh_c='sudo -E sh -c'\n        elif command_exists su; then\n            sh_c='su -c'\n        else\n            echo \"Error: this installer needs the ability to run commands as root.\"\n            echo \"We are unable to find either 'sudo' or 'su' available to make this happen.\"\n            exit 1\n        fi\n    fi\n    echo \"# Using command executor: $sh_c\"\n}\n\n# Refine distribution version detection based on the distro\nrefine_distribution_version() {\n    case \"$lsb_dist\" in\n        ubuntu)\n            if command_exists lsb_release; then\n                dist_version=\"$(lsb_release --codename | cut -f2)\"\n            fi\n            if [ -z \"$dist_version\" ] && [ -r /etc/lsb-release ]; then\n                \n                dist_version=\"$(. /etc/lsb-release && echo \"$DISTRIB_CODENAME\")\"\n            fi\n        ;;\n\n        debian|raspbian)\n            # If we only have a number, map it to a codename for better recognition\n            if echo \"$dist_version\" | grep -qE '^[0-9]+$'; then\n                case \"$dist_version\" in\n                    14)\n                        dist_version=\"forky\"\n                    ;;\n                    13)\n                        dist_version=\"trixie\"\n                    ;;\n                    12)\n                        dist_version=\"bookworm\"\n                    ;;\n                    11)\n                        dist_version=\"bullseye\"\n                    ;;\n                    10)\n                        # Handle special case for Buster\n                        dist_version=\"buster\"\n                        if [ \"$user\" = 'root' ]; then\n                            apt-get update --allow-releaseinfo-change || true\n                        elif command_exists sudo; then\n                            sudo apt-get update --allow-releaseinfo-change || true\n                        fi\n                    ;;\n                    9)\n                        dist_version=\"stretch\"\n                    ;;\n                    8)\n                        dist_version=\"jessie\"\n                    ;;\n                    7)\n                        dist_version=\"wheezy\"\n                    ;;\n                esac\n            fi\n        ;;\n\n        centos|rhel|fedora|ol)\n            # Make sure we have a version number\n            if [ -z \"$dist_version\" ] && [ -r /etc/os-release ]; then\n                \n                dist_version=\"$(. /etc/os-release && echo \"$VERSION_ID\")\"\n            fi\n            if [ -z \"$dist_version\" ] && [ -r /etc/redhat-release ]; then\n                dist_version=\"$(sed 's/.*release \\([0-9.]*\\).*/\\1/' /etc/redhat-release)\"\n            fi\n        ;;\n\n        sles|opensuse)\n            if [ -z \"$dist_version\" ] && [ -r /etc/os-release ]; then\n                dist_version=\"$(. /etc/os-release && echo \"$VERSION_ID\")\"\n            fi\n            # Fallback for older versions\n            if [ -z \"$dist_version\" ] && [ -r /etc/SuSE-release ]; then\n                dist_version=\"$(grep VERSION /etc/SuSE-release | sed 's/^VERSION = //')\"\n            fi\n            # Ensure version is in the correct format (e.g., 15.4 for SLES 15 SP4)\n            if [ -n \"$dist_version\" ]; then\n                # Remove any non-numeric characters except dots\n                dist_version=\"$(echo \"$dist_version\" | sed 's/[^0-9.]//g')\"\n            fi\n            # Normalize distribution name\n            if [ \"$lsb_dist\" = \"sles\" ]; then\n                lsb_dist=\"sles\"\n            elif [ \"$lsb_dist\" = \"opensuse\" ]; then\n                lsb_dist=\"opensuse\"\n            fi\n        ;;\n\n        *)\n            if command_exists lsb_release; then\n                dist_version=\"$(lsb_release --release | cut -f2)\"\n            fi\n            if [ -z \"$dist_version\" ] && [ -r /etc/os-release ]; then\n                \n                dist_version=\"$(. /etc/os-release && echo \"$VERSION_ID\")\"\n            fi\n        ;;\n    esac\n}\n\n# Init function\ninit() {\n    # Detect basic distribution info\n    get_distribution\n    \n    # Set up sudo for privileged commands\n    setup_sudo\n    \n    # Refine version information\n    refine_distribution_version\n    \n    # Check if this is a forked distro\n    check_forked\n    \n    # Print final distribution information\n    echo \"----------------------------------------\"\n    echo \"Linux Distribution: $lsb_dist\"\n    echo \"Version: $dist_version\"\n    echo \"----------------------------------------\"\n    \n}\n"),
	}
	filek := &embedded.EmbeddedFile{
		Filename:    "container-controller/install_docker.sh",
		FileModTime: time.Unix(1744130136, 0),

		Content: string("#!/bin/sh\n# Script to install Docker/Podman based on Linux distribution\n# Sources init.sh for distribution detection\n\nset -x\nset -e\n\nstart_docker() {\n    set +e\n    # check if docker is running\n    if ! $sh_c \"docker ps\" >/dev/null 2>&1; then\n        # Try init.d\n        $sh_c \"/etc/init.d/docker start\" >/dev/null 2>&1\n        local err_code=$?\n        # Try systemd\n        if [ $err_code -ne 0 ]; then\n            $sh_c \"systemctl start docker\" >/dev/null 2>&1\n            err_code=$?\n        fi\n        # Try service\n        if [ $err_code -ne 0 ]; then\n            $sh_c \"service docker start\" >/dev/null 2>&1\n            err_code=$?\n        fi\n        # Try snapd\n        if [ $err_code -ne 0 ]; then\n            $sh_c \"snap start docker\" >/dev/null 2>&1\n            err_code=$?\n        fi\n        if [ $err_code -ne 0 ]; then\n            echo \"Could not start Docker daemon\"\n            exit 1\n        fi\n    fi\n    set -e\n}\n\n\ndo_modify_daemon() {\n    # Skip for Podman installations\n    if [ \"$USE_PODMAN\" = \"true\" ]; then\n        echo \"# Configuring Podman for CDI directory support...\"\n\n        # Create CDI directories\n        $sh_c \"mkdir -p /etc/cdi /var/run/cdi\"\n\n        # Ensure /etc/containers exists\n        $sh_c \"mkdir -p /etc/containers\"\n\n        # Create containers.conf if it doesn't exist\n        if [ ! -f \"/etc/containers/containers.conf\" ]; then\n            $sh_c 'cat > /etc/containers/containers.conf <<EOF\n[engine]\nruntime = \"crun\"\ncdi_spec_dirs = [\"/etc/cdi\", \"/var/run/cdi\"]\nEOF'\n        else\n            # Check if [engine] block exists\n            if grep -q \"^\\[engine\\]\" /etc/containers/containers.conf; then\n                # Ensure runtime is set under [engine]\n                if grep -q \"^runtime\" /etc/containers/containers.conf; then\n                    $sh_c \"sed -i 's|^runtime *=.*|runtime = \\\"crun\\\"|' /etc/containers/containers.conf\"\n                else\n                    $sh_c \"sed -i '/^\\[engine\\]/a runtime = \\\"crun\\\"' /etc/containers/containers.conf\"\n                fi\n\n                # Ensure cdi_spec_dirs is set under [engine]\n                if grep -q \"^cdi_spec_dirs\" /etc/containers/containers.conf; then\n                    $sh_c \"sed -i 's|^cdi_spec_dirs *=.*|cdi_spec_dirs = [\\\"/etc/cdi\\\", \\\"/var/run/cdi\\\"]|' /etc/containers/containers.conf\"\n                else\n                    $sh_c \"sed -i '/^\\[engine\\]/a cdi_spec_dirs = [\\\"/etc/cdi\\\", \\\"/var/run/cdi\\\"]' /etc/containers/containers.conf\"\n                fi\n            else\n                # Append full engine block if missing\n                $sh_c 'echo -e \"\\n[engine]\\nruntime = \\\"crun\\\"\\ncdi_spec_dirs = [\\\"/etc/cdi\\\", \\\"/var/run/cdi\\\"]\" >> /etc/containers/containers.conf'\n            fi\n        fi\n\n        # Enable and start Podman services\n        $sh_c \"systemctl enable podman\"\n        $sh_c \"systemctl start podman\"\n        $sh_c \"systemctl enable podman.socket\"\n        $sh_c \"systemctl start podman.socket\"\n        return\n    fi\n    \n    # Original Docker daemon configuration\n    if [ ! -f /etc/docker/daemon.json ]; then\n        echo \"Creating /etc/docker/daemon.json...\"\n        $sh_c \"mkdir -p /etc/docker\"\n        $sh_c 'cat > /etc/docker/daemon.json << EOF\n{\n\t\"storage-driver\": \"overlayfs\",\n    \"features\": {\n        \"containerd-snapshotter\": true,\n        \"cdi\": true\n    },\n    \"cdi-spec-dirs\": [\"/etc/cdi/\", \"/var/run/cdi\"]\n}\nEOF'\n    else\n        echo \"/etc/docker/daemon.json already exists\"\n    fi\n    echo \"Restarting Docker daemon...\"\n    $sh_c \"systemctl daemon-reload\"\n    $sh_c \"systemctl restart docker\"\n}\n\ndo_set_datasance_repo() {\n    echo \"# Setting up Datasance repository for $lsb_dist...\"\n    \n    case \"$lsb_dist\" in\n        fedora|centos|rhel|ol|sles|opensuse*)\n            # RPM-based distros\n            $sh_c \"cd /etc/yum.repos.d && curl -s https://downloads.datasance.com/datasance.repo -LO\"\n            if [ \"$lsb_dist\" = \"fedora\" ] || [ \"$lsb_dist\" = \"centos\" ] || [ \"$lsb_dist\" = \"rhel\" ] || [ \"$lsb_dist\" = \"ol\" ]; then\n                $sh_c \"yum update -y\"\n            else\n                $sh_c \"zypper refresh\"\n            fi\n        ;;\n        debian|ubuntu|raspbian|*)\n            # DEB-based distros\n            $sh_c \"apt update -qy\"\n            $sh_c \"apt install -qy debian-archive-keyring apt-transport-https\"\n            $sh_c \"wget -qO- https://downloads.datasance.com/datasance.gpg | tee /etc/apt/trusted.gpg.d/datasance.gpg >/dev/null\"\n            $sh_c \"echo 'deb [arch=all signed-by=/etc/apt/trusted.gpg.d/datasance.gpg] https://downloads.datasance.com/deb stable main' | tee /etc/apt/sources.list.d/datasance.list >/dev/null\"\n            $sh_c \"apt update -qy\"\n        ;;\n    esac\n}\n\ndo_install_wasm_shim() {\n    echo \"# Installing WebAssembly runtime support for $lsb_dist...\"\n    arch=$(uname -m)\n\n    # Normalize architecture for consistency\n    case \"$arch\" in\n        arm64|aarch64|armv7l|armv8) arch=\"aarch64\" ;;\n        amd64|x86_64) arch=\"x86_64\" ;;\n    esac\n\n    if [ \"$USE_PODMAN\" = \"true\" ]; then\n        case \"$lsb_dist\" in\n            fedora|centos|rhel|ol)\n                $sh_c \"yum install -y crun crun-wasm\"\n            ;;\n            sles|opensuse*)\n                $sh_c \"zypper install -y crun\"\n                # Note: crun-wasm might not be available in SUSE repos\n                # In that case, we'll need to use the standard crun\n            ;;\n        esac\n        \n    else\n        # Original containerd WASM shim installation for Docker\n        case \"$lsb_dist\" in\n            debian|raspbian|ubuntu)\n                $sh_c \"apt update -qy\" || { echo \"Failed to update apt packages\"; exit 1; }\n\n                if [ \"$arch\" = \"aarch64\" ]; then\n                    $sh_c \"apt install -qy containerd-shim-wasmedge-v1-aarch64-linux-gnu\"\n                    $sh_c \"apt install -qy containerd-shim-wasmer-v1-aarch64-linux-gnu\"\n                    $sh_c \"apt install -qy containerd-shim-wasmtime-v1-aarch64-linux-gnu\"\n                elif [ \"$arch\" = \"x86_64\" ]; then\n                    $sh_c \"apt install -qy containerd-shim-wasmedge-v1-x86-64-linux-gnu\"\n                    $sh_c \"apt install -qy containerd-shim-wasmer-v1-x86-64-linux-gnu\"\n                    $sh_c \"apt install -qy containerd-shim-wasmtime-v1-x86-64-linux-gnu\"\n                else\n                    echo \"Unsupported architecture: $arch for $lsb_dist\"\n                    exit 1\n                fi\n            ;;\n            *)\n                echo \"Unsupported OS: $lsb_dist\"\n                exit 1\n            ;;\n        esac\n    fi\n}\n\ndo_install_container_engine() {\n    if [ \"$USE_PODMAN\" = \"true\" ]; then\n        echo \"# Installing Podman and related packages...\"\n        case \"$lsb_dist\" in\n            fedora|centos|rhel|ol)\n                $sh_c \"yum install -y podman crun podman-docker\"\n            ;;\n            sles|opensuse*)\n                $sh_c \"zypper install -y podman crun podman-docker\"\n            ;;\n        esac\n        \n        # Modify daemon and enable podman services\n\t\tdo_modify_daemon\n        return\n    fi\n    \n    # Docker installation for Debian-based systems only\n    if [ \"$USE_PODMAN\" = \"false\" ] && command_exists docker; then\n        docker_version=$(docker -v | sed 's/.*version \\(.*\\),.*/\\1/' | tr -d '.')\n        if [ \"$docker_version\" -ge 2500 ]; then\n            echo \"# Docker $docker_version already installed\"\n            start_docker\n            do_modify_daemon\n            return\n        fi\n    fi\n    \n    echo \"# Installing Docker...\"\n    case \"$lsb_dist\" in\n        debian|ubuntu|raspbian)\n            case \"$dist_version\" in\n                \"stretch\")\n                    $sh_c \"apt install -y apt-transport-https ca-certificates curl gnupg2 software-properties-common\"\n                    curl -fsSL https://download.docker.com/linux/debian/gpg | $sh_c \"apt-key add -\"\n                    $sh_c \"add-apt-repository \\\"deb [arch=$(dpkg --print-architecture)] https://download.docker.com/linux/debian $(lsb_release -cs) stable\\\"\"\n                    $sh_c \"apt update -y\"\n                    $sh_c \"apt install -y docker-ce\"\n                ;;\n                *)\n                    curl -fsSL https://get.docker.com/ | $sh_c \"sh\"\n                ;;\n            esac\n        ;;\n        *)\n            curl -fsSL https://get.docker.com/ | $sh_c \"sh\"\n        ;;\n    esac\n    \n    if ! command_exists docker; then\n        echo \"Failed to install Docker\"\n        exit 1\n    fi\n    start_docker\n    do_modify_daemon\n}\n\n# Check if we should use Podman based on distribution\ndetermine_container_engine() {\n    USE_PODMAN=\"false\"\n    case \"$lsb_dist\" in\n        fedora|centos|rhel|ol|sles|opensuse*)\n            USE_PODMAN=\"true\"\n            echo \"# Using Podman for $lsb_dist\"\n        ;;\n        *)\n            echo \"# Using Docker for $lsb_dist\"\n        ;;\n    esac\n}\n\n# Source init.sh to get distribution info\n. /etc/iofog/agent/init.sh\ninit\n\n# Configure container engine based on distribution\ndetermine_container_engine\n\n# Install appropriate container engine\ndo_install_container_engine\n\n# Set up Datasance repository\ndo_set_datasance_repo\n\n# Install WebAssembly runtime support\ndo_install_wasm_shim\n\necho \"# Installation completed successfully\""),
	}
	filel := &embedded.EmbeddedFile{
		Filename:    "container-controller/install_iofog.sh",
		FileModTime: time.Unix(1744136078, 0),

		Content: string("#!/bin/sh\nset -x\nset -e\n\n# INSTALL_DIR=\"/opt/iofog\"\nTMP_DIR=\"/tmp/iofog\"\nETC_DIR=\"/etc/iofog/controller\"\nCONTROLLER_LOG_FOLDER=/var/log/iofog-controller\nCONTROLLER_CONTAINER_NAME=\"iofog-controller\"\n\ncommand_exists() {\n    command -v \"$1\" >/dev/null 2>&1\n}\n\ndo_stop_iofog_controller() {\n    if command_exists iofog-controller; then\n        sudo systemctl stop iofog-controller\n    fi\n}\n\ndo_install_iofog_controller() {\n    echo \"# Installing ioFog controller...\"\n\n    # 1. Ensure folders exist\n    for FOLDER in ${ETC_DIR} ${CONTROLLER_LOG_FOLDER}; do\n        if [ ! -d \"$FOLDER\" ]; then\n            echo \"Creating folder: $FOLDER\"\n            sudo mkdir -p \"$FOLDER\"\n            sudo chmod 775 \"$FOLDER\"\n        fi\n    done\n\n    # Check if we're using Podman (RHEL, CentOS, Fedora, etc.)\n    if [ \"$lsb_dist\" = \"rhel\" ] || [ \"$lsb_dist\" = \"centos\" ] || [ \"$lsb_dist\" = \"fedora\" ] || [ \"$lsb_dist\" = \"ol\" ] || [ \"$lsb_dist\" = \"sles\" ] || [ \"$lsb_dist\" = \"opensuse\" ]; then\n        # Using Podman - Create Quadlet container file\n        echo \"Creating Quadlet container file for ioFog controller...\"\n        SYSTEMD_SERVICE_FILE=/etc/containers/systemd/iofog-controller.container\n\n        cat <<EOF | sudo tee ${SYSTEMD_SERVICE_FILE} > /dev/null\n[Unit]\nDescription=Datasance PoT IoFog Controller Service\nAfter=podman.service\nRequires=podman.service\n\n[Container]\nContainerName=${CONTROLLER_CONTAINER_NAME}\nImage=${controller_image}\nPodmanArgs=--stop-timeout=60\nEnvironment=IOFOG_CONTROLLER_IMAGE=${controller_image}\nEnvironmentFile=${ETC_DIR}/iofog-controller.env\nVolume=iofog-controller-db:/home/runner/.npm-global/lib/node_modules/@datasance/iofogcontroller/src/data/sqlite_files/:rw\nVolume=iofog-controller-log:/var/log/iofog-controller:rw\nPublishPort=51121:51121\nPublishPort=8008:8008\nLogDriver=journald\n\n[Service]\nRestart=always\n\n[Install]\nWantedBy=default.target\nEOF\n\n        # Reload systemd and enable the service\n        sudo systemctl daemon-reload\n        sudo systemctl restart podman\n        sudo systemctl start iofog-controller.service\n\n        # Create the executable script for Podman\n        echo \"Creating iofog-controller executable script...\"\n        EXECUTABLE_FILE=/usr/local/bin/iofog-controller\n\n        cat <<'EOF' | sudo tee ${EXECUTABLE_FILE} > /dev/null\n#!/bin/bash\nCONTAINER_NAME=\"iofog-controller\"\n\n# Check if the container is running\nif ! podman ps --format '{{.Names}}' | grep -q \"^${CONTAINER_NAME}$\"; then\n    echo \"Error: The iofog-controller container is not running.\"\n    exit 1\nfi\n\n# Execute the command in the container\npodman exec ${CONTAINER_NAME} iofog-controller \"$@\"\nEOF\n\n    else\n        # Using Docker - Create systemd service file\n        echo \"Creating systemd service for ioFog controller...\"\n        SYSTEMD_SERVICE_FILE=/etc/systemd/system/iofog-controller.service\n\n        cat <<EOF | sudo tee ${SYSTEMD_SERVICE_FILE} > /dev/null\n[Unit]\nDescription=Datasance PoT IoFog Controller Service\nAfter=docker.service\nRequires=docker.service\n\n[Service]\nTimeoutStartSec=0\nRestart=always\nExecStartPre=/usr/bin/docker pull ${controller_image} \nExecStartPre=-/usr/bin/docker rm -f ${CONTROLLER_CONTAINER_NAME}\nExecStart=/usr/bin/docker run --rm --name ${CONTROLLER_CONTAINER_NAME} \\\\\n-e IOFOG_CONTROLLER_IMAGE=${controller_image} \\\\\n--env-file ${ETC_DIR}/iofog-controller.env \\\\\n-v iofog-controller-db:/home/runner/.npm-global/lib/node_modules/@datasance/iofogcontroller/src/data/sqlite_files/:rw \\\\\n-v iofog-controller-log:/var/log/iofog-controller:rw \\\\\n-p 51121:51121 \\\\\n-p 8008:8008 \\\\\n--stop-timeout 60 \\\\\n--attach stdout \\\\\n--attach stderr \\\\\n${controller_image}\nExecStop=/usr/bin/docker stop ${CONTROLLER_CONTAINER_NAME}\n\n[Install]\nWantedBy=default.target\nEOF\n\n        # Reload systemd and enable the service\n        sudo systemctl daemon-reload\n        sudo systemctl enable iofog-controller.service\n        sudo systemctl start iofog-controller.service\n\n        # Create the executable script for Docker\n        echo \"Creating iofog-controller executable script...\"\n        EXECUTABLE_FILE=/usr/local/bin/iofog-controller\n\n        cat <<'EOF' | sudo tee ${EXECUTABLE_FILE} > /dev/null\n#!/bin/bash\nCONTAINER_NAME=\"iofog-controller\"\n\n# Check if the container is running\nif ! docker ps --format '{{.Names}}' | grep -q \"^${CONTAINER_NAME}$\"; then\n    echo \"Error: The iofog-controller container is not running.\"\n    exit 1\nfi\n\n# Execute the command in the container\ndocker exec ${CONTAINER_NAME} iofog-controller \"$@\"\nEOF\n    fi\n\n    # Make the script executable\n    sudo chmod +x ${EXECUTABLE_FILE}\n\n    echo \"ioFog controller installation completed!\"\n}\n\n# main\ncontroller_image=\"$1\"\n\n. /etc/iofog/controller/init.sh\ninit\ndo_stop_iofog_controller\ndo_install_iofog_controller\n"),
	}
	filem := &embedded.EmbeddedFile{
		Filename:    "container-controller/set_env.sh",
		FileModTime: time.Unix(1738603394, 0),

		Content: string("#!/bin/sh\nset -x\nset -e\n\nETC_DIR=\"/etc/iofog/controller\"\nENV_FILE_NAME=iofog-controller.env # Used as an env file in systemd\n\nENV_FILE=\"$ETC_DIR/$ENV_FILE_NAME\"\n\n# Create folder\nmkdir -p \"$ETC_DIR\"\n\n# Env file (for systemd)\nrm -f \"$ENV_FILE\"\ntouch \"$ENV_FILE\"\n\nfor var in \"$@\"\ndo\n  echo \"$var\" >> \"$ENV_FILE\"\ndone"),
	}
	filen := &embedded.EmbeddedFile{
		Filename:    "container-controller/uninstall_iofog.sh",
		FileModTime: time.Unix(1744137476, 0),

		Content: string("#!/bin/sh\nset -x\nset -e\n\n\nCONTROLLER_LOG_DIR=\"iofog-controller-log\"\nCONTAINER_NAME=\"iofog-controller\"\nEXECUTABLE_FILE=/usr/local/bin/iofog-controller\nCONTROLLER_DB=iofog-controller-db\n\n\ndo_uninstall_controller() {\n    echo \"# Removing ioFog controller...\"\n\n    # Set the appropriate systemd service file based on the Linux distribution\n    if [ \"$lsb_dist\" = \"rhel\" ] || [ \"$lsb_dist\" = \"fedora\" ] || [ \"$lsb_dist\" = \"centos\" ] || [ \"$lsb_dist\" = \"ol\" ] || [ \"$lsb_dist\" = \"sles\" ] || [ \"$lsb_dist\" = \"opensuse\" ]; then\n        SYSTEMD_SERVICE_FILE=/etc/containers/systemd/iofog-controller.container\n        CONTAINER_RUNTIME=\"podman\"\n    else\n        SYSTEMD_SERVICE_FILE=/etc/systemd/system/iofog-controller.service\n        CONTAINER_RUNTIME=\"docker\"\n    fi\n\n    # Disable and stop the systemd service\n    if [ -f ${SYSTEMD_SERVICE_FILE} ]; then\n        echo \"Disabling and stopping the systemd service...\"\n        sudo systemctl stop iofog-controller.service || true\n        sudo systemctl disable iofog-controller.service || true\n        sudo rm -f ${SYSTEMD_SERVICE_FILE}\n        sudo systemctl daemon-reload\n    fi\n\n    # Remove the container\n    if ${CONTAINER_RUNTIME} ps --format '{{.Names}}' | grep -q \"^${CONTAINER_NAME}$\"; then\n        echo \"Stopping and removing the ioFog controller container...\"\n        ${CONTAINER_RUNTIME} stop ${CONTAINER_NAME}\n        ${CONTAINER_RUNTIME} rm ${CONTAINER_NAME}\n    fi\n\n    # Remove config files\n    echo \"Checking if the ${CONTAINER_RUNTIME} volume exists...\"\n\n    if sudo ${CONTAINER_RUNTIME} volume inspect \"${CONTROLLER_DB}\" >/dev/null 2>&1; then\n        echo \"${CONTAINER_RUNTIME} volume '${CONTROLLER_DB}' found. Removing...\"\n        sudo ${CONTAINER_RUNTIME} volume rm \"${CONTROLLER_DB}\"\n        echo \"${CONTAINER_RUNTIME} volume '${CONTROLLER_DB}' has been removed.\"\n    else\n        echo \"${CONTAINER_RUNTIME} volume '${CONTROLLER_DB}' does not exist. Skipping removal.\"\n    fi\n\n    # Remove log files\n    echo \"Removing log files...\"\n    if sudo ${CONTAINER_RUNTIME} volume inspect \"${CONTROLLER_LOG_DIR}\" >/dev/null 2>&1; then\n        echo \"${CONTAINER_RUNTIME} volume '${CONTROLLER_LOG_DIR}' found. Removing...\"\n        sudo ${CONTAINER_RUNTIME} volume rm \"${CONTROLLER_LOG_DIR}\"\n        echo \"${CONTAINER_RUNTIME} volume '${CONTROLLER_LOG_DIR}' has been removed.\"\n    else\n        echo \"${CONTAINER_RUNTIME} volume '${CONTROLLER_LOG_DIR}' does not exist. Skipping removal.\"\n    fi\n\n\n    # Remove the executable script\n    if [ -f ${EXECUTABLE_FILE} ]; then\n        echo \"Removing the iofog-controller executable script...\"\n        sudo rm -f ${EXECUTABLE_FILE}\n    fi\n\n    echo \"ioFog controller uninstalled successfully!\"\n}\n\n. /etc/iofog/controller/init.sh\ninit\n\ndo_uninstall_controller"),
	}
	filep := &embedded.EmbeddedFile{
		Filename:    "controller/check_prereqs.sh",
		FileModTime: time.Unix(1681101988, 0),

		Content: string("#!/bin/sh\nset -x\n\n# Check can sudo without password\nif ! $(sudo ls /tmp/ > /dev/null); then\n\tMSG=\"Unable to successfully use sudo with user $USER on this host.\\nUser $USER must be in sudoers group and using sudo without password must be enabled.\\nPlease see iofog.org documentation for more details.\"\n\techo $MSG\n\texit 1\nfi\n"),
	}
	fileq := &embedded.EmbeddedFile{
		Filename:    "controller/install_iofog.sh",
		FileModTime: time.Unix(1738603394, 0),

		Content: string("#!/bin/sh\nset -x\nset -e\n\nINSTALL_DIR=\"/opt/iofog\"\nTMP_DIR=\"/tmp/iofog\"\nETC_DIR=\"/etc/iofog/controller\"\n\ncontroller_service() {\n    USE_SYSTEMD=`grep -m1 -c systemd /proc/1/comm`\n    USE_INITCTL=`which initctl | wc -l`\n    USE_SERVICE=`which service | wc -l`\n\n    if [ $USE_SYSTEMD -eq 1 ]; then\n        cp \"$ETC_DIR/service/iofog-controller.systemd\" /etc/systemd/system/iofog-controller.service\n        chmod 644 /etc/systemd/system/iofog-controller.service\n        systemctl daemon-reload\n        systemctl enable iofog-controller.service\n    elif [ $USE_INITCTL -eq 1 ]; then\n        cp \"$ETC_DIR/service/iofog-controller.initctl\" /etc/init/iofog-controller.conf\n        initctl reload-configuration\n    elif [ $USE_SERVICE -eq 1 ]; then\n        cp \"$ETC_DIR/service/iofog-controller.update-rc\" /etc/init.d/iofog-controller\n        chmod +x /etc/init.d/iofog-controller\n        update-rc.d iofog-controller defaults\n    else\n        echo \"Unable to setup Controller startup script.\"\n    fi\n}\n\ninstall_package() {\n\t\tif [ -z \"$(command -v apt)\" ]; then\n\t\t\techo \"Unsupported distro\"\n\t\t\texit 1\n\t\tfi\n\t\tapt update -qq\n\t\tapt install -y $1\n}\n\ninstall_deps() {\n\tif [ -z \"$(command -v curl)\" ]; then\n        install_package \"curl\"\n\tfi\n\n\tif [ -z \"$(command -v lsof)\" ]; then\n        install_package \"lsof\"\n\tfi\n\n\tif [ -z \"$(command -v make)\" ]; then\n        install_package \"build-essential\"\n\tfi\n\n\tif [ -z \"$(command -v python2)\" ]; then\n        install_package \"python2\"\n\tfi\n\n\tif [ -z \"$(command -v python3)\" ]; then\n        install_package \"python3\"\n\tfi\n\n\tif [ -z \"$(command -v python-is-python3)\" ]; then\n        install_package \"python-is-python3\"\n\tfi\n}\n\ncreate_logrotate() {\n    cat <<EOF > /etc/logrotate.d/iofog-controller\n/var/log/iofog-controller/iofog-controller.log {\n  rotate 10\n  size 100m\n  compress\n  notifempty\n  missingok\n  postrotate\n      kill -HUP `cat $INSTALL_DIR/controller/lib/node_modules/@datasance/iofogcontroller/src/iofog-controller.pid`\n}\nEOF\n    chmod 644 /etc/logrotate.d/iofog-controller\n}\n\ndeploy_controller() {\n\t# Nuke any existing instances\n\tif [ ! -z \"$(lsof -ti tcp:51121)\" ]; then\n\t\tlsof -ti tcp:51121 | xargs kill\n\tfi\n\n# #\t If token is provided, set up private repo\n# \tif [ ! -z $token ]; then\n# \t\tif [ ! -z $(npmrc | grep iofog) ]; then\n# \t\t\tnpmrc -c iofog\n# \t\t\tnpmrc iofog\n# \t\tfi\n# \t\tcurl -s https://\"$token\":@packagecloud.io/install/repositories/\"$repo\"/script.node.sh?package_id=7463817 | force_npm=1 bash\n# \t\tmv ~/.npmrc ~/.npmrcs/npmrc\n# \t\tln -s ~/.npmrcs/npmrc ~/.npmrc\n# \telse\n# \t\tnpmrc default\n# \tfi\n\t# Save DB\n\tif [ -f \"$INSTALL_DIR/controller/lib/node_modules/@datasance/iofogcontroller/package.json\" ]; then\n\t\t# If iofog-controller is not running, it will fail to stop - ignore that failure.\n\t\tnode $INSTALL_DIR/controller/lib/node_modules/@datasance/iofogcontroller/scripts/scripts-api.js preuninstall > /dev/null 2>&1 || true\n\tfi\n\n\t# Install in temporary location\n\tmkdir -p \"$TMP_DIR/controller\"\n\tchmod 0777 \"$TMP_DIR/controller\"\n\tif [ -z $version ]; then\n\t\tnpm install -g -f @datasance/iofogcontroller --unsafe-perm --prefix \"$TMP_DIR/controller\"\n\telse\n\t\tnpm install -g -f @datasance/iofogcontroller --unsafe-perm --prefix \"$TMP_DIR/controller\"\n\tfi\n\t# Move files into $INSTALL_DIR/controller\n\tmkdir -p \"$INSTALL_DIR/\"\n\trm -rf \"$INSTALL_DIR/controller\" # Clean possible previous install\n\tmv \"$TMP_DIR/controller/\" \"$INSTALL_DIR/\"\n\n\t# Restore DB\n\tif [ -f \"$INSTALL_DIR/controller/lib/node_modules/@datasance/iofogcontroller/package.json\" ]; then\n\t\tnode $INSTALL_DIR/controller/lib/node_modules/@datasance/iofogcontroller/scripts/scripts-api.js postinstall > /dev/null 2>&1 || true\n\tfi\n\n\t# Symbolic links\n\tif [ ! -f \"/usr/local/bin/iofog-controller\" ]; then\n\t\tln -fFs \"$INSTALL_DIR/controller/bin/iofog-controller\" /usr/local/bin/iofog-controller\n\tfi\n\n\t# Set controller permissions\n\tchmod 744 -R \"$INSTALL_DIR/controller\"\n\n\t# Startup script\n\tcontroller_service\n\n\t# Run controller\n\t. /opt/iofog/config/controller/env.sh\n\tiofog-controller start\n}\n\n# main\nversion=\"$1\"\n# repo=$([ -z \"$2\" ] && echo \"iofog/iofog-controller-snapshots\" || echo \"$2\")\n# token=\"$3\"\n\ninstall_deps\ncreate_logrotate\ndeploy_controller\n"),
	}
	filer := &embedded.EmbeddedFile{
		Filename:    "controller/install_node.sh",
		FileModTime: time.Unix(1735589285, 0),

		Content: string("#!/bin/sh\nset -x\nset -e\n\nload_existing_nvm() {\n\tset +e\n\tif [ -z \"$(command -v nvm)\" ]; then\n\t\texport NVM_DIR=\"${HOME}/.nvm\"\n\t\tmkdir -p $NVM_DIR\n\t\tif [ -f \"$NVM_DIR/nvm.sh\" ]; then\n\t\t\t[ -s \"$NVM_DIR/nvm.sh\" ] && \\. \"$NVM_DIR/nvm.sh\" # This loads nvm\n\t\tfi\n\tfi\n\tset -e\n}\n\ninstall_node() {\n\tload_existing_nvm\n\tif [ -z \"$(command -v nvm)\" ]; then\n\t\tcurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/refs/tags/v0.40.1/install.sh | bash\n\t\texport NVM_DIR=\"${HOME}/.nvm\"\n\t\t[ -s \"$NVM_DIR/nvm.sh\" ] && \\. \"$NVM_DIR/nvm.sh\"\n\tfi\n\tnvm install  v20.17.0\n\tnvm use  v20.17.0\n\tln -Ffs $(which node) /usr/local/bin/node\n\tln -Ffs $(which npm) /usr/local/bin/npm\n\n\t# npmrc\n\tif [ -z \"$(command -v npmrc)\" ]; then\n\t\tnpm i npmrc -g\n\tfi\n\tln -Ffs $(which npmrc) /usr/local/bin/npmrc\n}\n\ninstall_node"),
	}
	filet := &embedded.EmbeddedFile{
		Filename:    "controller/service/iofog-controller.initctl",
		FileModTime: time.Unix(1681101988, 0),

		Content: string("description \"ioFog Controller\"\n\nstart on (runlevel [2345])\nstop on (runlevel [!2345])\n\nrespawn\n\nscript\n  . /opt/iofog/config/controller/env.sh\n  exec /usr/local/bin/iofog-controller start\nend script"),
	}
	fileu := &embedded.EmbeddedFile{
		Filename:    "controller/service/iofog-controller.systemd",
		FileModTime: time.Unix(1681101988, 0),

		Content: string("[Unit]\nDescription=ioFog Controller\n\n[Service]\nType=forking\nExecStart=/usr/local/bin/iofog-controller start\nExecStop=/usr/local/bin/iofog-controller stop\nEnvironmentFile=/opt/iofog/config/controller/env.env\n\n[Install]\nWantedBy=multi-user.target\n"),
	}
	filev := &embedded.EmbeddedFile{
		Filename:    "controller/service/iofog-controller.update-rc",
		FileModTime: time.Unix(1681101988, 0),

		Content: string("#!/bin/sh\n\ncase \"$1\" in\n  start)\n    . /opt/iofog/controller/env.env\n    /usr/local/bin/iofog-controller start\n    ;;\n  stop)\n    /usr/local/bin/iofog-controller stop\n    ;;\n  restart)\n    /usr/local/bin/iofog-controller stop\n    . /opt/iofog/config/controller/env.sh\n    /usr/local/bin/iofog-controller start\n    ;;\n  *)\n    echo \"Usage: $0 {start|stop|restart}\"\nesac\n"),
	}
	filew := &embedded.EmbeddedFile{
		Filename:    "controller/set_env.sh",
		FileModTime: time.Unix(1681101988, 0),

		Content: string("#!/bin/sh\nset -x\nset -e\n\nCONF_FOLDER=/opt/iofog/config/controller\nSOURCE_FILE_NAME=env.sh # Used to source env variables\nENV_FILE_NAME=env.env # Used as an env file in systemd\n\nSOURCE_FILE=\"$CONF_FOLDER/$SOURCE_FILE_NAME\"\nENV_FILE=\"$CONF_FOLDER/$ENV_FILE_NAME\"\n\n# Create folder\nmkdir -p \"$CONF_FOLDER\"\n\n# Source file\necho \"#!/bin/sh\" > \"$SOURCE_FILE\"\n\n# Env file (for systemd)\nrm -f \"$ENV_FILE\"\ntouch \"$ENV_FILE\"\n\nfor var in \"$@\"\ndo\n  echo \"export $var\" >> \"$SOURCE_FILE\"\n  echo \"$var\" >> \"$ENV_FILE\"\ndone"),
	}
	filex := &embedded.EmbeddedFile{
		Filename:    "controller/uninstall_iofog.sh",
		FileModTime: time.Unix(1681101988, 0),

		Content: string("#!/bin/sh\nset -x\nset -e\n\nCONTROLLER_DIR=\"/opt/iofog/controller/\"\nCONTROLLER_LOG_DIR=\"/var/log/iofog/\"\n\ndo_uninstall_controller() {\n  # Remove folders\n  sudo rm -rf $CONTROLLER_DIR\n  sudo rm -rf $CONTROLLER_LOG_DIR\n\n  # Remove symbolic links\n  rm -f /usr/local/bin/iofog-controller\n\n  # Remove service files\n  USE_SYSTEMD=`grep -m1 -c systemd /proc/1/comm`\n  USE_INITCTL=`which initctl | wc -l`\n  USE_SERVICE=`which service | wc -l`\n\n  if [ $USE_SYSTEMD -eq 1 ]; then\n    systemctl stop iofog-controller.service\n    rm -f /etc/systemd/system/iofog-controller.service\n  elif [ $USE_INITCTL -eq 1 ]; then\n    rm -f /etc/init/iofog-controller.conf\n  elif [ $USE_SERVICE -eq 1 ]; then\n    rm -f /etc/init.d/iofog-controller\n  else\n    echo \"Unable to setup Controller startup script.\"\n  fi\n}\n\ndo_uninstall_controller"),
	}

	// define dirs
	dir1 := &embedded.EmbeddedDir{
		Filename:   "",
		DirModTime: time.Unix(1738603394, 0),
		ChildFiles: []*embedded.EmbeddedFile{},
	}
	dir2 := &embedded.EmbeddedDir{
		Filename:   "agent",
		DirModTime: time.Unix(1738603394, 0),
		ChildFiles: []*embedded.EmbeddedFile{
			file3, // "agent/check_prereqs.sh"
			file4, // "agent/init.sh"
			file5, // "agent/install_deps.sh"
			file6, // "agent/install_docker.sh"
			file7, // "agent/install_iofog.sh"
			file8, // "agent/install_java.sh"
			file9, // "agent/uninstall_iofog.sh"

		},
	}
	dira := &embedded.EmbeddedDir{
		Filename:   "container-agent",
		DirModTime: time.Unix(1738603394, 0),
		ChildFiles: []*embedded.EmbeddedFile{
			fileb, // "container-agent/check_prereqs.sh"
			filec, // "container-agent/init.sh"
			filed, // "container-agent/install_deps.sh"
			filee, // "container-agent/install_docker.sh"
			filef, // "container-agent/install_iofog.sh"
			fileg, // "container-agent/uninstall_iofog.sh"

		},
	}
	dirh := &embedded.EmbeddedDir{
		Filename:   "container-controller",
		DirModTime: time.Unix(1738603394, 0),
		ChildFiles: []*embedded.EmbeddedFile{
			filei, // "container-controller/check_prereqs.sh"
			filej, // "container-controller/init.sh"
			filek, // "container-controller/install_docker.sh"
			filel, // "container-controller/install_iofog.sh"
			filem, // "container-controller/set_env.sh"
			filen, // "container-controller/uninstall_iofog.sh"

		},
	}
	diro := &embedded.EmbeddedDir{
		Filename:   "controller",
		DirModTime: time.Unix(1738603394, 0),
		ChildFiles: []*embedded.EmbeddedFile{
			filep, // "controller/check_prereqs.sh"
			fileq, // "controller/install_iofog.sh"
			filer, // "controller/install_node.sh"
			filew, // "controller/set_env.sh"
			filex, // "controller/uninstall_iofog.sh"

		},
	}
	dirs := &embedded.EmbeddedDir{
		Filename:   "controller/service",
		DirModTime: time.Unix(1681101988, 0),
		ChildFiles: []*embedded.EmbeddedFile{
			filet, // "controller/service/iofog-controller.initctl"
			fileu, // "controller/service/iofog-controller.systemd"
			filev, // "controller/service/iofog-controller.update-rc"

		},
	}

	// link ChildDirs
	dir1.ChildDirs = []*embedded.EmbeddedDir{
		dir2, // "agent"
		dira, // "container-agent"
		dirh, // "container-controller"
		diro, // "controller"

	}
	dir2.ChildDirs = []*embedded.EmbeddedDir{}
	dira.ChildDirs = []*embedded.EmbeddedDir{}
	dirh.ChildDirs = []*embedded.EmbeddedDir{}
	diro.ChildDirs = []*embedded.EmbeddedDir{
		dirs, // "controller/service"

	}
	dirs.ChildDirs = []*embedded.EmbeddedDir{}

	// register embeddedBox
	embedded.RegisterEmbeddedBox(`../../assets`, &embedded.EmbeddedBox{
		Name: `../../assets`,
		Time: time.Unix(1738603394, 0),
		Dirs: map[string]*embedded.EmbeddedDir{
			"":                     dir1,
			"agent":                dir2,
			"container-agent":      dira,
			"container-controller": dirh,
			"controller":           diro,
			"controller/service":   dirs,
		},
		Files: map[string]*embedded.EmbeddedFile{
			"agent/check_prereqs.sh":                        file3,
			"agent/init.sh":                                 file4,
			"agent/install_deps.sh":                         file5,
			"agent/install_docker.sh":                       file6,
			"agent/install_iofog.sh":                        file7,
			"agent/install_java.sh":                         file8,
			"agent/uninstall_iofog.sh":                      file9,
			"container-agent/check_prereqs.sh":              fileb,
			"container-agent/init.sh":                       filec,
			"container-agent/install_deps.sh":               filed,
			"container-agent/install_docker.sh":             filee,
			"container-agent/install_iofog.sh":              filef,
			"container-agent/uninstall_iofog.sh":            fileg,
			"container-controller/check_prereqs.sh":         filei,
			"container-controller/init.sh":                  filej,
			"container-controller/install_docker.sh":        filek,
			"container-controller/install_iofog.sh":         filel,
			"container-controller/set_env.sh":               filem,
			"container-controller/uninstall_iofog.sh":       filen,
			"controller/check_prereqs.sh":                   filep,
			"controller/install_iofog.sh":                   fileq,
			"controller/install_node.sh":                    filer,
			"controller/service/iofog-controller.initctl":   filet,
			"controller/service/iofog-controller.systemd":   fileu,
			"controller/service/iofog-controller.update-rc": filev,
			"controller/set_env.sh":                         filew,
			"controller/uninstall_iofog.sh":                 filex,
		},
	})
}
